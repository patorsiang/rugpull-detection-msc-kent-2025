{
  "opcode_sequence": "",
  "opcode_entropy": 0.0,
  "opcode_count": 0,
  "unique_opcodes": 0,
  "byte_entropy": 0.0,
  "byte_0x": 1.0,
  "num_nodes": 0,
  "num_edges": 0,
  "avg_degree": 0,
  "density": 0,
  "connected_components": 0,
  "avg_clustering": 0,
  "timeline_sequence": [],
  "sourcecode": "library ArrayLib {\n  // Inserts to keep array sorted (assumes input array is sorted)\n\tfunction insertInPlace(uint8[] storage self, uint8 n) {\n\t\tuint8 insertingIndex = 0;\n\n\t\twhile (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) {\n\t\t\tinsertingIndex += 1;\n\t\t}\n\n\t\tself.length += 1;\n\t\tfor (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) {\n\t\t\tself[i] = self[i - 1];\n\t\t}\n\n\t\tself[insertingIndex] = n;\n\t}\n}\n\nlibrary DeckLib {\n\tusing ArrayLib for uint8[];\n\n\tenum Suit { Spades, Hearts, Clubs, Diamonds }\n\tuint8 constant cardsPerSuit = 13;\n\tuint8 constant suits = 4;\n\tuint8 constant totalCards = cardsPerSuit * suits;\n\n\tstruct Deck {\n\t\tuint8[] usedCards; // always has to be sorted\n\t\taddress player;\n\t\tuint256 gameID;\n\t}\n\n\tfunction init(Deck storage self, uint256 gameID)  {\n\t\tself.usedCards = new uint8[](0);\n\t\tself.player = msg.sender;\n\t\tself.gameID = gameID;\n\t}\n\n\tfunction getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  {\n\t\tuint cardIndex = self.usedCards.length;\n\t\tif (cardIndex >= totalCards) throw;\n\t\tuint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex));\n\n\t\tfor (uint8 i = 0; i < cardIndex; i++) {\n\t\t\tif (self.usedCards[i] <= r) r += 1;\n\t\t}\n\n\t\tself.usedCards.insertInPlace(r);\n\n\t\treturn r;\n\t}\n\n\tfunction cardDescription(uint8 self) constant returns (Suit, uint8) {\n\t\treturn (Suit(self / cardsPerSuit), cardFacevalue(self));\n\t}\n\n\tfunction cardEmojified(uint8 self) constant returns (uint8, string) {\n\t\tstring memory emojiSuit;\n\n\t\tvar (suit, number) = cardDescription(self);\n\t\tif (suit == Suit.Clubs) emojiSuit = \"\u2663\ufe0f\";\n\t\telse if (suit == Suit.Diamonds) emojiSuit = \"\u2666\ufe0f\";\n\t\telse if (suit == Suit.Hearts) emojiSuit = \"\u2665\ufe0f\";\n\t\telse if (suit == Suit.Spades) emojiSuit = \"\u2660\ufe0f\";\n\n\t\treturn (number, emojiSuit);\n\t}\n\n\tfunction cardFacevalue(uint8 self) constant returns (uint8) {\n\t\treturn 1 + self % cardsPerSuit;\n\t}\n\n\tfunction blackjackValue(uint8 self) constant returns (uint8) {\n\t\tuint8 cardValue = cardFacevalue(self);\n\t\treturn cardValue < 10 ? cardValue : 10;\n\t}\n\n\tfunction getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) {\n\t\t// Uses blockhash as randomness source.\n\t\t// Credits: https://github.com/Bunjin/Rouleth/blob/master/Provably_Fair_No_Cheating.md\n\t\tbytes32 blockHash = block.blockhash(b);\n\t\tif (blockHash == 0x0) throw;\n\t\treturn uint(uint256(keccak256(blockHash, player, gameID, n)) % m);\n\n\t}\n}\n\ncontract AbstractBlockjackLogs {\n  event GameEnded(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand);\n  event GameNeedsTick(uint256 gameID, address player, uint256 actionBlock);\n\n  function recordLog(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand);\n  function tickRequiredLog(uint256 gameID, address player, uint256 actionBlock);\n}\n\nlibrary GameLib {\n  using DeckLib for *;\n\n  uint8 constant houseLimit = 17;\n  uint8 constant target = 21;\n\n  enum ComparaisonResult { First, Second, Tie }\n  enum GameState { InitialCards, Waiting, Hit, Stand, DoubleDown, Finished }\n  enum GameResult { Ongoing, House, Tie, Player, PlayerNatural }\n\n  struct Game {\n    address player;\n    uint256 bet;\n    uint256 payout;\n    uint256 gameID;\n\n    DeckLib.Deck deck;\n    uint8[] houseCards;\n    uint8[] playerCards;\n\n    uint256 actionBlock; // Block on which commitment to perform an action happens.\n\n    GameState state;\n    GameResult result;\n\n    bool closed;\n  }\n\n  function init(Game storage self, uint256 gameID) {\n    self.player = msg.sender;\n    self.bet = msg.value;\n    self.payout = 0;\n    self.houseCards = new uint8[](0);\n    self.playerCards = new uint8[](0);\n    self.actionBlock = block.number;\n    self.state = GameState.InitialCards;\n    self.result = GameResult.Ongoing;\n    self.closed = false;\n    self.gameID = gameID;\n\n    self.deck.init(gameID);\n  }\n\n  function tick(Game storage self) returns (bool) {\n    if (block.number <= self.actionBlock) return false; // Can't tick yet\n    if (self.actionBlock + 255 < block.number) {\n      endGame(self, GameResult.House);\n      return true;\n    }\n    if (!needsTick(self)) return true; // not needed, everything is fine\n\n    if (self.state == GameState.InitialCards) dealInitialCards(self);\n    if (self.state == GameState.Hit) dealHitCard(self);\n    if (self.state == GameState.DoubleDown) {\n      if (!canDoubleDown(self)) throw;\n      self.bet += msg.value;\n      dealHitCard(self);\n      forceStand(self);\n    }\n\n    if (self.state == GameState.Stand) {\n      dealHouseCards(self);\n      checkGameResult(self);\n    } else {\n      checkGameContinues(self);\n    }\n\n    return true;\n  }\n\n  function needsTick(Game storage self) constant returns (bool) {\n    if (self.state == GameState.Waiting) return false;\n    if (self.state == GameState.Finished) return false;\n\n    return true;\n  }\n\n  function checkGameResult(Game storage self)  {\n    uint8 houseHand = countHand(self.houseCards);\n\n    if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); // House natural\n\n    ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards));\n    if (result == ComparaisonResult.First) return endGame(self, GameResult.House);\n    if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player);\n\n    endGame(self, GameResult.Tie);\n  }\n\n  function checkGameContinues(Game storage self)  {\n    uint8 playerHand = countHand(self.playerCards);\n    if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); // player natural\n    if (playerHand > target) return endGame(self, GameResult.House); // Player busted\n    if (playerHand == target) {\n      // Player is forced to stand with 21\n      forceStand(self);\n      if (!tick(self)) throw; // Forces tick, commitment to play actually happened past block\n    }\n  }\n\n  function forceStand(Game storage self) {\n    uint256 currentActionBlock = self.actionBlock;\n    playerDecision(self, GameState.Stand);\n    self.actionBlock = currentActionBlock;\n  }\n\n  function canDoubleDown(Game storage self) returns (bool) {\n    if (self.playerCards.length > 2) return false;\n    uint8 totalPlayer = countHand(self.playerCards);\n    if (totalPlayer < 9 || totalPlayer > 11) return false;\n    if (msg.value != self.bet) return false;\n  }\n\n  function playerDecision(Game storage self, GameState decision)  {\n    if (self.state != GameState.Waiting) throw;\n    if (decision != GameState.Hit && decision != GameState.Stand) throw;\n\n    self.state = decision;\n    self.actionBlock = block.number;\n  }\n\n  function dealInitialCards(Game storage self) private {\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\n    self.houseCards.push(self.deck.getCard(self.actionBlock));\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\n\n    self.state = GameState.Waiting;\n  }\n\n  function dealHitCard(Game storage self) private {\n    self.playerCards.push(self.deck.getCard(self.actionBlock));\n\n    self.state = GameState.Waiting;\n  }\n\n  function dealHouseCards(Game storage self) private {\n    self.houseCards.push(self.deck.getCard(self.actionBlock));\n\n    if (countHand(self.houseCards) < houseLimit) dealHouseCards(self);\n  }\n\n  function endGame(Game storage self, GameResult result) {\n    self.result = result;\n    self.state = GameState.Finished;\n    self.payout = payoutForResult(self.result, self.bet);\n\n    closeGame(self);\n  }\n\n  function closeGame(Game storage self) private {\n    if (self.closed) throw; // cannot re-close\n    if (self.state != GameState.Finished) throw; // not closable\n\n    self.closed = true;\n\n    if (self.payout > 0) {\n      if (!self.player.send(self.payout)) throw;\n    }\n  }\n\n  function payoutForResult(GameResult result, uint256 bet) private returns (uint256) {\n    if (result == GameResult.PlayerNatural) return bet * 5 / 2; // bet + 1.5x bet\n    if (result == GameResult.Player) return bet * 2; // doubles bet\n    if (result == GameResult.Tie) return bet; // returns bet\n\n    return 0;\n  }\n\n  function countHand(uint8[] memory hand)  returns (uint8) {\n    uint8[] memory possibleSums = new uint8[](1);\n\n    for (uint i = 0; i < hand.length; i++) {\n      uint8 value = hand[i].blackjackValue();\n      uint l = possibleSums.length;\n      for (uint j = 0; j < l; j++) {\n        possibleSums[j] += value;\n        if (value == 1) { // is Ace\n          possibleSums = appendArray(possibleSums, possibleSums[j] + 10); // Fork possible sum with 11 as ace value.\n        }\n      }\n    }\n\n    return bestSum(possibleSums);\n  }\n\n  function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) {\n    bestSum = 50; // very bad hand\n    for (uint i = 0; i < possibleSums.length; i++) {\n      if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) {\n        bestSum = possibleSums[i];\n      }\n    }\n    return;\n  }\n\n  function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) {\n    uint8[] memory newArray = new uint8[](array.length + 1);\n    for (uint8 i = 0; i < array.length; i++) {\n      newArray[i] = array[i];\n    }\n    newArray[array.length] = n;\n    return newArray;\n  }\n\n  function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) {\n    if (a <= target && b <= target) {\n      if (a > b) return ComparaisonResult.First;\n      if (a < b) return ComparaisonResult.Second;\n    }\n\n    if (a > target && b > target) {\n      if (a < b) return ComparaisonResult.First;\n      if (a > b) return ComparaisonResult.Second;\n    }\n\n    if (a > target) return ComparaisonResult.Second;\n    if (b > target) return ComparaisonResult.First;\n\n    return ComparaisonResult.Tie;\n  }\n}\n\ncontract Blockjack {\n  AbstractBlockjackLogs blockjacklogs;\n\n  using GameLib for GameLib.Game;\n\n  GameLib.Game[] games;\n  mapping (address => uint256) public currentGame;\n\n  bool contractCleared;\n  // Initial settings\n  uint256 public minBet = 50 finney;\n  uint256 public maxBet = 500 finney;\n  bool public allowsNewGames = false;\n  uint256 public maxBlockActions = 10;\n\n  mapping (uint256 => uint256) blockActions;\n\n  // Admin\n\n  //kovan\n  //  address public DX =       0x0006426a1057cbc60762802FFb5FBdc55D008fAf;\n  //  address public DEV =      0x0031EDb4846BAb2EDEdd7f724E58C50762a45Cb2;\n\n  //main\n  address public DX = 0x296Ae1d2D9A8701e113EcdF6cE986a4a7D0A6dC5;\n  address public DEV = 0xBC4343B11B7cfdd6dD635f61039b8a66aF6E73Bb;\n\n\n\n  address public ADMIN_CONTRACT;\n\n  uint256 public BANKROLL_LOCK_PERIOD = 30 days;\n\n  uint256 public bankrollLockedUntil;\n  uint256 public profitsLockedUntil;\n  uint256 public initialBankroll;\n  uint256 public currentBankroll;\n\n  mapping (address => bool) public isOwner;\n\n  modifier onlyOwner {\n    if (!isOwner[msg.sender]) throw;\n    _;\n  }\n\n  modifier only(address x) {\n    if (msg.sender != x) throw;\n    _;\n  }\n\n  modifier onlyPlayer(uint256 gameID) {\n    if (msg.sender != games[gameID].player) throw;\n    _;\n  }\n\n  modifier blockActionProtected {\n    blockActions[block.number] += 1;\n    if (blockActions[block.number] > maxBlockActions) throw;\n    _;\n  }\n\n  function Blockjack(address _admin_contract, address _logs_contract) { // only(DEV) {\n    ADMIN_CONTRACT = _admin_contract;\n    blockjacklogs = AbstractBlockjackLogs(_logs_contract);\n    games.length += 1;\n    games[0].init(0); // Init game 0 so indices start on 1\n    games[0].player = this;\n    setupTrustedAccounts();\n  }\n\n  function () payable {\n    startGame();\n  }\n\n  function startGame() blockActionProtected payable {\n    if (!allowsNewGames) throw;\n    if (msg.value < minBet) throw;\n    if (msg.value > maxBet) throw;\n\n    // check if player has game opened\n    uint256 currentGameId = currentGame[msg.sender];\n    if (games.length > currentGameId) {\n      GameLib.Game openedGame = games[currentGameId];\n      if (openedGame.player == msg.sender && !openedGame.closed) { // Check for index 0 mapping problems\n\tif (!openedGame.tick()) throw;\n\tif (!openedGame.closed) throw; // cannot start game with on-going game\n\trecordEndedGame(currentGameId);\n      }\n    }\n    uint256 newGameID = games.length;\n\n    games.length += 1;\n    games[newGameID].init(newGameID);\n    currentGame[msg.sender] = newGameID;\n    tickRequiredLog(games[newGameID]);\n  }\n\n  function hit(uint256 gameID) onlyPlayer(gameID) blockActionProtected {\n    GameLib.Game game = games[gameID];\n\n    if (!game.tick()) throw;\n    game.playerDecision(GameLib.GameState.Hit);\n    tickRequiredLog(game);\n  }\n\n  function doubleDown(uint256 gameID) onlyPlayer(gameID) blockActionProtected payable {\n    GameLib.Game game = games[gameID];\n\n    if (!game.tick()) throw;\n    game.playerDecision(GameLib.GameState.DoubleDown);\n    tickRequiredLog(game);\n  }\n\n  function stand(uint256 gameID) onlyPlayer(gameID) blockActionProtected {\n    GameLib.Game game = games[gameID];\n\n    if (!game.tick()) throw;\n    game.playerDecision(GameLib.GameState.Stand);\n    tickRequiredLog(game);\n  }\n\n  function gameTick(uint256 gameID) blockActionProtected {\n    GameLib.Game openedGame = games[gameID];\n    if (openedGame.closed) throw;\n    if (!openedGame.tick()) throw;\n    if (openedGame.closed) recordEndedGame(gameID);\n  }\n\n  function recordEndedGame(uint gameID) private {\n    GameLib.Game openedGame = games[gameID];\n\n    //vs potential overflow when croupier is not ticking frequently enough\n    if(currentBankroll + openedGame.bet > openedGame.payout){\n      currentBankroll = currentBankroll + openedGame.bet - openedGame.payout;\n    }\n\n    blockjacklogs.recordLog(\n\t\t\t    openedGame.gameID,\n\t\t\t    openedGame.player,\n\t\t\t    uint(openedGame.result),\n\t\t\t    openedGame.payout,\n\t\t\t    GameLib.countHand(openedGame.playerCards),\n\t\t\t    GameLib.countHand(openedGame.houseCards)\n\t\t\t    );\n  }\n\n  function tickRequiredLog(GameLib.Game storage game) private {\n    blockjacklogs.tickRequiredLog(game.gameID, game.player, game.actionBlock);\n  }\n\n  // Constants\n\n  function gameState(uint i) constant returns (uint8[], uint8[], uint8, uint8, uint256, uint256, uint8, uint8, bool, uint256) {\n    GameLib.Game game = games[i];\n\n    return (\n\t    game.houseCards,\n\t    game.playerCards,\n\t    GameLib.countHand(game.houseCards),\n\t    GameLib.countHand(game.playerCards),\n\t    game.bet,\n\t    game.payout,\n\t    uint8(game.state),\n\t    uint8(game.result),\n\t    game.closed,\n\t    game.actionBlock\n\t    );\n  }\n\n  // Admin\n  function setupTrustedAccounts()\n    internal\n  {\n    isOwner[DX] = true;\n    isOwner[DEV] = true;\n    isOwner[ADMIN_CONTRACT] = true;\n  }\n\n  function changeDev(address newDev) only(DEV) {\n    isOwner[DEV] = false;\n    DEV = newDev;\n    isOwner[DEV] = true;\n  }\n\n  function changeDX(address newDX) only(DX) {\n    isOwner[DX] = false;\n    DX = newDX;\n    isOwner[DX] = true;\n  }\n\n  function changeAdminContract(address _new_admin_contract) only(ADMIN_CONTRACT) {\n    isOwner[ADMIN_CONTRACT] = false;\n    ADMIN_CONTRACT = _new_admin_contract;\n    isOwner[ADMIN_CONTRACT] = true;\n  }\n\n  function setSettings(uint256 _min, uint256 _max, uint256 _maxBlockActions) only(ADMIN_CONTRACT) {\n    minBet = _min;\n    maxBet = _max;\n    maxBlockActions = _maxBlockActions;\n  }\n\n  function registerOwner(address _new_watcher) only(ADMIN_CONTRACT) {\n    isOwner[_new_watcher] = true;\n  }\n\n  function removeOwner(address _old_watcher) only(ADMIN_CONTRACT) {\n    isOwner[_old_watcher] = false;\n  }\n\n  function stopBlockjack() onlyOwner {\n    allowsNewGames = false;\n  }\n\n  function startBlockjack() only(ADMIN_CONTRACT) {\n    allowsNewGames = true;\n  }\n\n  function addBankroll() only(DX) payable {\n    initialBankroll += msg.value;\n    currentBankroll += msg.value;\n  }\n\n  function remainingBankroll() constant returns (uint256) {\n    return currentBankroll > initialBankroll ? initialBankroll : currentBankroll;\n  }\n\n  function removeBankroll() only(DX) {\n    if (initialBankroll > currentBankroll - 5 ether && bankrollLockedUntil > now) throw;\n\n    stopBlockjack();\n\n    if (currentBankroll > initialBankroll) { // there are profits\n      if (!DEV.send(currentBankroll - initialBankroll)) throw;\n    }\n\n    suicide(DX); // send rest to dx\n    contractCleared = true;\n  }\n\n  function migrateBlockjack() only(ADMIN_CONTRACT) {\n    stopBlockjack();\n\n    if (currentBankroll > initialBankroll) { // there are profits, share them\n      if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n    }\n    suicide(DX); // send rest to dx\n    //DX will have to refund the non finalized bets that may have been stopped\n  }\n\n  function shareProfits() onlyOwner {\n    if (profitsLockedUntil > now) throw;\n    if (currentBankroll <= initialBankroll) throw; // there are no profits\n\n    uint256 profit = currentBankroll - initialBankroll;\n    if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n    currentBankroll -= profit;\n\n    bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;\n    profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;\n  }\n}"
}