{
  "opcode_sequence": "PUSH1 PUSH1 MSTORE CALLVALUE DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP PUSH1 CALLDATASIZE LT PUSH2 JUMPI PUSH1 CALLDATALOAD PUSH1 PUSH1 EXP SWAP1 DIV DUP1 PUSH4 GT PUSH2 JUMPI DUP1 PUSH4 GT PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI PUSH2 JUMP JUMPDEST DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI PUSH2 JUMP JUMPDEST DUP1 PUSH4 GT PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI PUSH2 JUMP JUMPDEST DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI JUMPDEST PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP1 MLOAD PUSH1 DUP1 DUP3 MSTORE DUP4 MLOAD DUP2 DUP4 ADD MSTORE DUP4 MLOAD SWAP2 SWAP3 DUP4 SWAP3 SWAP1 DUP4 ADD SWAP2 DUP6 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 JUMPI DUP2 DUP2 ADD MLOAD DUP4 DUP3 ADD MSTORE PUSH1 ADD PUSH2 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 AND DUP1 ISZERO PUSH2 JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 DUP4 PUSH1 SUB PUSH2 EXP SUB NOT AND DUP2 MSTORE PUSH1 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP1 MLOAD SWAP2 DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 RETURN JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP PUSH1 PUSH1 PUSH1 EXP SUB DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 DUP2 ADD CALLDATALOAD SWAP1 SWAP2 AND SWAP1 PUSH1 ADD CALLDATALOAD PUSH2 JUMP JUMPDEST PUSH1 DUP1 MLOAD SWAP2 ISZERO ISZERO DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 RETURN JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP1 MLOAD PUSH1 SWAP1 SWAP3 AND DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 RETURN JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP PUSH1 PUSH1 PUSH1 EXP SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 ADD CALLDATALOAD PUSH2 JUMP JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP3 AND DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 RETURN JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP PUSH1 PUSH1 PUSH1 EXP SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 ADD CALLDATALOAD ISZERO ISZERO PUSH2 JUMP JUMPDEST STOP JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH2 JUMP JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH2 JUMP JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH2 JUMP JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP PUSH1 PUSH1 PUSH1 EXP SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 ADD CALLDATALOAD PUSH2 JUMP JUMPDEST PUSH2 PUSH1 DUP1 CALLDATASIZE SUB PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH2 JUMP JUMPDEST PUSH1 DUP1 SLOAD PUSH1 DUP1 MLOAD PUSH1 PUSH1 PUSH1 DUP6 AND ISZERO PUSH2 MUL PUSH1 NOT ADD SWAP1 SWAP5 AND SWAP4 SWAP1 SWAP4 DIV PUSH1 DUP2 ADD DUP5 SWAP1 DIV DUP5 MUL DUP3 ADD DUP5 ADD SWAP1 SWAP3 MSTORE DUP2 DUP2 MSTORE SWAP3 SWAP2 DUP4 ADD DUP3 DUP3 DUP1 ISZERO PUSH2 JUMPI DUP1 PUSH1 LT PUSH2 JUMPI PUSH2 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 ADD SWAP2 PUSH2 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 MSTORE PUSH1 PUSH1 SHA3 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 ADD SWAP1 PUSH1 ADD DUP1 DUP4 GT PUSH2 JUMPI DUP3 SWAP1 SUB PUSH1 AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST CALLER PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP2 SHA3 SLOAD PUSH1 AND ISZERO ISZERO PUSH1 EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST DUP4 PUSH20 PUSH4 DUP3 PUSH1 MLOAD DUP3 PUSH4 AND PUSH1 PUSH1 EXP MUL DUP2 MSTORE PUSH1 ADD DUP1 DUP3 PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 MSTORE PUSH1 ADD SWAP2 POP POP PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD DUP1 PUSH2 JUMPI POP PUSH1 DUP1 MLOAD PUSH1 PUSH1 EXP PUSH4 MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 DUP3 ADD MSTORE SWAP1 MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD JUMPDEST ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST DUP4 PUSH20 PUSH4 DUP3 PUSH1 MLOAD DUP3 PUSH4 AND PUSH1 PUSH1 EXP MUL DUP2 MSTORE PUSH1 ADD DUP1 DUP3 PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 MSTORE PUSH1 ADD SWAP2 POP POP PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD DUP1 PUSH2 JUMPI POP PUSH1 DUP1 MLOAD PUSH1 PUSH1 EXP PUSH4 MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 DUP3 ADD MSTORE SWAP1 MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD JUMPDEST ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 DUP7 DUP7 DUP7 PUSH2 JUMP JUMPDEST POP PUSH1 SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 SLOAD PUSH1 AND DUP2 JUMP JUMPDEST CALLER PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP2 SHA3 SLOAD PUSH1 AND ISZERO ISZERO PUSH1 EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST DUP3 PUSH20 PUSH4 DUP3 PUSH1 MLOAD DUP3 PUSH4 AND PUSH1 PUSH1 EXP MUL DUP2 MSTORE PUSH1 ADD DUP1 DUP3 PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 MSTORE PUSH1 ADD SWAP2 POP POP PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD DUP1 PUSH2 JUMPI POP PUSH1 DUP1 MLOAD PUSH1 PUSH1 EXP PUSH4 MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 DUP3 ADD MSTORE SWAP1 MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD JUMPDEST ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 DUP5 DUP5 PUSH2 JUMP JUMPDEST POP PUSH1 SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 SLOAD PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH1 SLOAD PUSH1 DUP1 MLOAD PUSH32 DUP2 MSTORE CALLER PUSH1 DUP3 ADD MSTORE PUSH1 PUSH1 PUSH1 EXP SUB SWAP4 DUP5 AND PUSH1 DUP3 ADD MSTORE SWAP3 SWAP1 SWAP2 AND PUSH1 DUP4 ADD MSTORE MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP3 AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB SWAP2 SWAP1 SWAP2 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 DUP1 SLOAD PUSH1 NOT AND SWAP2 ISZERO ISZERO SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 SLOAD PUSH1 SLOAD PUSH1 DUP1 MLOAD PUSH32 DUP2 MSTORE CALLER PUSH1 DUP3 ADD MSTORE PUSH1 PUSH1 PUSH1 EXP SUB SWAP4 DUP5 AND PUSH1 DUP3 ADD MSTORE SWAP3 SWAP1 SWAP2 AND PUSH1 DUP4 ADD MSTORE MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH20 NOT AND PUSH1 PUSH1 PUSH1 EXP SUB SWAP3 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 PUSH1 MSTORE PUSH1 SWAP1 DUP2 MSTORE PUSH1 SWAP1 SHA3 SLOAD DUP2 JUMP JUMPDEST PUSH1 DUP1 SLOAD PUSH1 DUP1 MLOAD PUSH1 PUSH1 PUSH1 DUP6 AND ISZERO PUSH2 MUL PUSH1 NOT ADD SWAP1 SWAP5 AND SWAP4 SWAP1 SWAP4 DIV PUSH1 DUP2 ADD DUP5 SWAP1 DIV DUP5 MUL DUP3 ADD DUP5 ADD SWAP1 SWAP3 MSTORE DUP2 DUP2 MSTORE SWAP3 SWAP2 DUP4 ADD DUP3 DUP3 DUP1 ISZERO PUSH2 JUMPI DUP1 PUSH1 LT PUSH2 JUMPI PUSH2 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 ADD SWAP2 PUSH2 JUMP JUMPDEST PUSH1 PUSH1 MSTORE PUSH1 SWAP1 DUP2 MSTORE PUSH1 SWAP1 SHA3 SLOAD PUSH1 AND DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 JUMP JUMPDEST CALLER PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP2 SHA3 SLOAD PUSH1 AND ISZERO ISZERO PUSH1 EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST DUP3 PUSH20 PUSH4 DUP3 PUSH1 MLOAD DUP3 PUSH4 AND PUSH1 PUSH1 EXP MUL DUP2 MSTORE PUSH1 ADD DUP1 DUP3 PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 MSTORE PUSH1 ADD SWAP2 POP POP PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD DUP1 PUSH2 JUMPI POP PUSH1 DUP1 MLOAD PUSH1 PUSH1 EXP PUSH4 MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 DUP3 ADD MSTORE SWAP1 MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD JUMPDEST ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP5 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD DUP4 GT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP5 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD PUSH2 SWAP1 DUP5 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP6 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SSTORE PUSH1 SLOAD PUSH2 SWAP1 DUP5 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 SSTORE PUSH1 DUP1 MLOAD DUP5 DUP2 MSTORE SWAP1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB DUP7 AND SWAP2 PUSH32 SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 LOG2 POP PUSH1 SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 SLOAD PUSH1 SLOAD PUSH1 DUP1 MLOAD PUSH32 DUP2 MSTORE CALLER PUSH1 DUP3 ADD MSTORE PUSH1 PUSH1 PUSH1 EXP SUB SWAP4 DUP5 AND PUSH1 DUP3 ADD MSTORE SWAP3 SWAP1 SWAP2 AND PUSH1 DUP4 ADD MSTORE MLOAD PUSH20 SWAP2 PUSH4 SWAP2 PUSH1 DUP1 DUP4 ADD SWAP3 PUSH1 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP GAS DELEGATECALL ISZERO DUP1 ISZERO PUSH2 JUMPI RETURNDATASIZE PUSH1 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 REVERT JUMPDEST POP POP POP POP PUSH1 MLOAD RETURNDATASIZE PUSH1 DUP2 LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP MLOAD ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH20 NOT AND PUSH1 PUSH1 PUSH1 EXP SUB SWAP3 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP3 AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD DUP2 GT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP3 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD PUSH2 DUP2 DUP4 PUSH4 PUSH2 AND JUMP JUMPDEST LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP1 DUP4 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP1 DUP3 SHA3 SLOAD SWAP3 DUP7 AND DUP3 MSTORE DUP2 SHA3 SLOAD SWAP1 SWAP2 PUSH2 SWAP2 SWAP1 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP6 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD SWAP1 SWAP2 POP PUSH2 SWAP1 DUP4 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP1 DUP7 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP1 DUP3 SHA3 SWAP4 SWAP1 SWAP4 SSTORE SWAP1 DUP6 AND DUP2 MSTORE SHA3 SLOAD PUSH2 SWAP1 DUP4 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP1 DUP6 AND PUSH1 DUP2 DUP2 MSTORE PUSH1 PUSH1 SWAP1 DUP2 MSTORE PUSH1 SWAP2 DUP3 SWAP1 SHA3 SWAP5 SWAP1 SWAP5 SSTORE DUP1 MLOAD DUP7 DUP2 MSTORE SWAP1 MLOAD SWAP2 SWAP4 SWAP3 DUP9 AND SWAP3 PUSH32 SWAP3 SWAP2 DUP3 SWAP1 SUB ADD SWAP1 LOG3 PUSH1 PUSH1 PUSH1 EXP SUB DUP1 DUP5 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP1 DUP3 SHA3 SLOAD SWAP3 DUP8 AND DUP3 MSTORE SWAP1 SHA3 SLOAD DUP3 SWAP2 PUSH2 SWAP2 SWAP1 PUSH4 PUSH2 AND JUMP JUMPDEST EQ PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP3 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD PUSH2 SWAP1 DUP3 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SSTORE PUSH1 SLOAD PUSH2 SWAP1 DUP3 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 SSTORE PUSH1 DUP1 MLOAD DUP3 DUP2 MSTORE SWAP1 MLOAD ADDRESS SWAP2 PUSH1 SWAP2 PUSH32 SWAP2 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 LOG3 PUSH1 DUP1 MLOAD DUP3 DUP2 MSTORE SWAP1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB DUP5 AND SWAP2 ADDRESS SWAP2 PUSH32 SWAP2 DUP2 SWAP1 SUB PUSH1 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 DUP3 DUP3 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST POP SWAP1 SUB SWAP1 JUMP JUMPDEST DUP2 DUP2 ADD DUP3 DUP2 LT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST SWAP3 SWAP2 POP POP JUMP UNKNOWN_0xfe LOG1 PUSH6 SHA3 UNKNOWN_0x25 EXTCODECOPY UNKNOWN_0xd0 PUSH19 UNKNOWN_0xb8 LOG3 UNKNOWN_0xce UNKNOWN_0xde UNKNOWN_0xb3 CREATE2 MSTORE UNKNOWN_0xc2 INVALID_0x78",
  "opcode_entropy": 4.792023228352615,
  "opcode_count": 2712,
  "unique_opcodes": 70,
  "byte_entropy": 5.931716654910634,
  "byte_60": 0.11502738747320791,
  "byte_80": 0.04405810907358895,
  "byte_40": 0.015003572279114075,
  "byte_52": 0.021909978566325317,
  "byte_34": 0.0014289116456299119,
  "byte_15": 0.026196713503215053,
  "byte_61": 0.037628006668254346,
  "byte_00": 0.048106692069540366,
  "byte_10": 0.00904977375565611,
  "byte_57": 0.021909978566325317,
  "byte_fd": 0.015479876160990712,
  "byte_5b": 0.030245296499166466,
  "byte_50": 0.032626815908549656,
  "byte_04": 0.0076208621100261964,
  "byte_36": 0.0023815194093831865,
  "byte_f9": 0.0009526077637532746,
  "byte_35": 0.004048582995951417,
  "byte_e0": 0.0014289116456299119,
  "byte_02": 0.025244105739461776,
  "byte_0a": 0.015003572279114075,
  "byte_90": 0.030483448440104786,
  "byte_63": 0.011669445105977614,
  "byte_53": 0.0004763038818766373,
  "byte_d6": 0.0004763038818766373,
  "byte_59": 0.0007144558228149559,
  "byte_11": 0.0042867349368897354,
  "byte_9b": 0.0019052155275065491,
  "byte_19": 0.0021433674684448677,
  "byte_25": 0.0007144558228149559,
  "byte_1a": 0.0004763038818766373,
  "byte_6a": 0.002619671350321505,
  "byte_14": 0.0057156465825196475,
  "byte_d9": 0.0004763038818766373,
  "byte_a9": 0.0004763038818766373,
  "byte_b6": 0.0028578232912598238,
  "byte_b3": 0.0014289116456299119,
  "byte_8e": 0.00023815194093831864,
  "byte_ff": 0.024053346034770183,
  "byte_b1": 0.00023815194093831864,
  "byte_e1": 0.00023815194093831864,
  "byte_9d": 0.0007144558228149559,
  "byte_45": 0.0004763038818766373,
  "byte_03": 0.02333889021195523,
  "byte_07": 0.004048582995951417,
  "byte_f2": 0.0021433674684448677,
  "byte_e3": 0.0007144558228149559,
  "byte_8b": 0.00023815194093831864,
  "byte_33": 0.0019052155275065491,
  "byte_56": 0.012145748987854251,
  "byte_55": 0.0023815194093831865,
  "byte_5c": 0.0030959752321981426,
  "byte_fa": 0.00023815194093831864,
  "byte_ef": 0.0014289116456299119,
  "byte_85": 0.0019052155275065491,
  "byte_70": 0.0014289116456299119,
  "byte_a0": 0.011669445105977614,
  "byte_82": 0.01595618004286735,
  "byte_31": 0.0007144558228149559,
  "byte_ab": 0.0028578232912598238,
  "byte_95": 0.0023815194093831865,
  "byte_d8": 0.00023815194093831864,
  "byte_41": 0.00023815194093831864,
  "byte_d1": 0.0004763038818766373,
  "byte_23": 0.0011907597046915933,
  "byte_b8": 0.0009526077637532746,
  "byte_72": 0.00357227911407478,
  "byte_dd": 0.0014289116456299119,
  "byte_d7": 0.00023815194093831864,
  "byte_01": 0.04048582995951417,
  "byte_3c": 0.0009526077637532746,
  "byte_e5": 0.00023815194093831864,
  "byte_67": 0.00023815194093831864,
  "byte_e7": 0.0004763038818766373,
  "byte_c1": 0.0004763038818766373,
  "byte_0f": 0.0014289116456299119,
  "byte_05": 0.003334127173136461,
  "byte_4e": 0.00023815194093831864,
  "byte_f0": 0.0004763038818766373,
  "byte_06": 0.003334127173136461,
  "byte_de": 0.0030959752321981426,
  "byte_fe": 0.0014289116456299119,
  "byte_a2": 0.0007144558228149559,
  "byte_46": 0.0028578232912598238,
  "byte_7b": 0.00023815194093831864,
  "byte_18": 0.0004763038818766373,
  "byte_16": 0.021909978566325317,
  "byte_0d": 0.0021433674684448677,
  "byte_51": 0.016194331983805668,
  "byte_20": 0.021909978566325317,
  "byte_83": 0.01238390092879257,
  "byte_81": 0.02786377708978328,
  "byte_91": 0.016670635865682307,
  "byte_92": 0.00904977375565611,
  "byte_28": 0.0023815194093831865,
  "byte_1f": 0.0014289116456299119,
  "byte_6d": 0.00023815194093831864,
  "byte_f3": 0.0014289116456299119,
  "byte_ed": 0.0004763038818766373,
  "byte_d3": 0.0009526077637532746,
  "byte_1b": 0.0009526077637532746,
  "byte_8c": 0.00023815194093831864,
  "byte_39": 0.0007144558228149559,
  "byte_6b": 0.0007144558228149559,
  "byte_fc": 0.0023815194093831865,
  "byte_08": 0.0050011907597046915,
  "byte_fb": 0.00023815194093831864,
  "byte_09": 0.0014289116456299119,
  "byte_1d": 0.00023815194093831864,
  "byte_8f": 0.0028578232912598238,
  "byte_49": 0.00023815194093831864,
  "byte_0c": 0.0009526077637532746,
  "byte_54": 0.010002381519409383,
  "byte_94": 0.0011907597046915933,
  "byte_93": 0.0028578232912598238,
  "byte_84": 0.00714455822814956,
  "byte_df": 0.0011907597046915933,
  "byte_b4": 0.0007144558228149559,
  "byte_c2": 0.0011907597046915933,
  "byte_73": 0.003334127173136461,
  "byte_d5": 0.002619671350321505,
  "byte_32": 0.0030959752321981426,
  "byte_99": 0.002619671350321505,
  "byte_b7": 0.0028578232912598238,
  "byte_27": 0.002619671350321505,
  "byte_4d": 0.003334127173136461,
  "byte_26": 0.0030959752321981426,
  "byte_29": 0.0030959752321981426,
  "byte_2d": 0.0009526077637532746,
  "byte_86": 0.0042867349368897354,
  "byte_3b": 0.002619671350321505,
  "byte_79": 0.00023815194093831864,
  "byte_5a": 0.003334127173136461,
  "byte_f4": 0.002619671350321505,
  "byte_8d": 0.0009526077637532746,
  "byte_3d": 0.007859014050964515,
  "byte_3e": 0.0028578232912598238,
  "byte_a3": 0.0011907597046915933,
  "byte_e2": 0.0016670635865682305,
  "byte_0b": 0.0028578232912598238,
  "byte_2f": 0.0009526077637532746,
  "byte_ca": 0.0009526077637532746,
  "byte_24": 0.0016670635865682305,
  "byte_1c": 0.00023815194093831864,
  "byte_a5": 0.0007144558228149559,
  "byte_b9": 0.00023815194093831864,
  "byte_cf": 0.0007144558228149559,
  "byte_48": 0.0004763038818766373,
  "byte_5e": 0.00023815194093831864,
  "byte_6c": 0.0004763038818766373,
  "byte_77": 0.00023815194093831864,
  "byte_ad": 0.0011907597046915933,
  "byte_12": 0.0007144558228149559,
  "byte_ce": 0.0007144558228149559,
  "byte_a1": 0.0011907597046915933,
  "byte_b5": 0.00023815194093831864,
  "byte_cb": 0.00023815194093831864,
  "byte_42": 0.00023815194093831864,
  "byte_7f": 0.0016670635865682305,
  "byte_f6": 0.0016670635865682305,
  "byte_ac": 0.0014289116456299119,
  "byte_44": 0.0009526077637532746,
  "byte_64": 0.0007144558228149559,
  "byte_98": 0.00023815194093831864,
  "byte_ae": 0.00023815194093831864,
  "byte_bb": 0.00023815194093831864,
  "byte_d0": 0.0004763038818766373,
  "byte_17": 0.0007144558228149559,
  "byte_97": 0.0004763038818766373,
  "byte_ba": 0.0004763038818766373,
  "byte_b0": 0.0009526077637532746,
  "byte_3f": 0.00023815194093831864,
  "byte_a4": 0.00023815194093831864,
  "byte_dc": 0.00023815194093831864,
  "byte_2a": 0.0004763038818766373,
  "byte_cc": 0.0004763038818766373,
  "byte_f5": 0.0019052155275065491,
  "byte_db": 0.00023815194093831864,
  "byte_87": 0.0004763038818766373,
  "byte_1e": 0.00023815194093831864,
  "byte_bd": 0.00023815194093831864,
  "byte_7a": 0.0007144558228149559,
  "byte_71": 0.0004763038818766373,
  "byte_5d": 0.00023815194093831864,
  "byte_7c": 0.0004763038818766373,
  "byte_76": 0.00023815194093831864,
  "byte_0e": 0.0011907597046915933,
  "byte_13": 0.00023815194093831864,
  "byte_74": 0.00023815194093831864,
  "byte_88": 0.00023815194093831864,
  "byte_c8": 0.0007144558228149559,
  "byte_69": 0.0009526077637532746,
  "byte_68": 0.0007144558228149559,
  "byte_37": 0.0007144558228149559,
  "byte_aa": 0.0007144558228149559,
  "byte_2b": 0.0007144558228149559,
  "byte_a7": 0.0007144558228149559,
  "byte_f1": 0.0007144558228149559,
  "byte_c4": 0.0007144558228149559,
  "byte_30": 0.0007144558228149559,
  "byte_22": 0.00023815194093831864,
  "byte_65": 0.00023815194093831864,
  "byte_62": 0.00023815194093831864,
  "byte_58": 0.00023815194093831864,
  "byte_9e": 0.00023815194093831864,
  "byte_c7": 0.00023815194093831864,
  "byte_38": 0.00023815194093831864,
  "byte_2c": 0.00023815194093831864,
  "byte_cd": 0.00023815194093831864,
  "byte_6f": 0.00023815194093831864,
  "byte_66": 0.00023815194093831864,
  "byte_3a": 0.00023815194093831864,
  "byte_78": 0.00023815194093831864,
  "num_nodes": 2,
  "num_edges": 1,
  "avg_degree": 1.0,
  "density": 0.5,
  "connected_components": 1,
  "avg_clustering": 0.0,
  "txn_nums": 3,
  "event_nums": 0,
  "creation_block": 7886417,
  "creation_timestamp": 1559564696,
  "life_time": 1576.0,
  "duration_seconds": 21798.0,
  "from_creation_to_transfer": 0.0,
  "num_addresses": 3,
  "num_buyers": 1,
  "num_sellers": 1,
  "num_creator_transfers": 0,
  "buy_amt": 0,
  "sell_amt": 0.0,
  "avg_value": 0.0,
  "txn_per_block": 0.0019023462270133164,
  "avg_gas_limit": 6950000.0,
  "std_gas_limit": 0.0,
  "avg_gas_used": 476410.3333333333,
  "std_gas_used": 618746.8440896397,
  "avg_gas_price": 10000000000.0,
  "std_gas_price": 0.0,
  "atinversebrah_num": 1,
  "setwhitelist_num": 1,
  "transferownership_num": 1,
  "timeline_sequence": [
    [
      7886417,
      1559564696,
      28,
      9,
      0,
      6950000,
      10000000000,
      0,
      1,
      1800064,
      1351406,
      15234493
    ],
    [
      7886826,
      1559570216,
      96,
      27,
      0,
      6950000,
      10000000000,
      0,
      1,
      1060653,
      46556,
      15234084
    ],
    [
      7887993,
      1559586494,
      303,
      10,
      0,
      6950000,
      10000000000,
      0,
      1,
      476954,
      31269,
      15232917
    ]
  ],
  "sourcecode": "pragma solidity >=0.5.4 <0.6.0;\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t * @dev Multiplies two numbers, throws on overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Integer division of two numbers, truncating the quotient.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @dev Adds two numbers, throws on overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n\ninterface INameTAOPosition {\n\tfunction senderIsAdvocate(address _sender, address _id) external view returns (bool);\n\tfunction senderIsListener(address _sender, address _id) external view returns (bool);\n\tfunction senderIsSpeaker(address _sender, address _id) external view returns (bool);\n\tfunction senderIsPosition(address _sender, address _id) external view returns (bool);\n\tfunction getAdvocate(address _id) external view returns (address);\n\tfunction nameIsAdvocate(address _nameId, address _id) external view returns (bool);\n\tfunction nameIsPosition(address _nameId, address _id) external view returns (bool);\n\tfunction initialize(address _id, address _advocateId, address _listenerId, address _speakerId) external returns (bool);\n\tfunction determinePosition(address _sender, address _id) external view returns (uint256);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenERC20 {\n\t// Public variables of the token\n\tstring public name;\n\tstring public symbol;\n\tuint8 public decimals = 18;\n\t// 18 decimals is the strongly suggested default, avoid changing it\n\tuint256 public totalSupply;\n\n\t// This creates an array with all balances\n\tmapping (address => uint256) public balanceOf;\n\tmapping (address => mapping (address => uint256)) public allowance;\n\n\t// This generates a public event on the blockchain that will notify clients\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t// This generates a public event on the blockchain that will notify clients\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\t// This notifies clients about the amount burnt\n\tevent Burn(address indexed from, uint256 value);\n\n\t/**\n\t * Constructor function\n\t *\n\t * Initializes contract with initial supply tokens to the creator of the contract\n\t */\n\tconstructor (uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n\t\tname = tokenName;                                   // Set the name for display purposes\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\n\t}\n\n\t/**\n\t * Internal transfer, only can be called by this contract\n\t */\n\tfunction _transfer(address _from, address _to, uint _value) internal {\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\n\t\trequire(_to != address(0));\n\t\t// Check if the sender has enough\n\t\trequire(balanceOf[_from] >= _value);\n\t\t// Check for overflows\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\n\t\t// Save this for an assertion in the future\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\n\t\t// Subtract from the sender\n\t\tbalanceOf[_from] -= _value;\n\t\t// Add the same to the recipient\n\t\tbalanceOf[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\t}\n\n\t/**\n\t * Transfer tokens\n\t *\n\t * Send `_value` tokens to `_to` from your account\n\t *\n\t * @param _to The address of the recipient\n\t * @param _value the amount to send\n\t */\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n\t\t_transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Transfer tokens from other address\n\t *\n\t * Send `_value` tokens to `_to` in behalf of `_from`\n\t *\n\t * @param _from The address of the sender\n\t * @param _to The address of the recipient\n\t * @param _value the amount to send\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\n\t\tallowance[_from][msg.sender] -= _value;\n\t\t_transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set allowance for other address\n\t *\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\n\t *\n\t * @param _spender The address authorized to spend\n\t * @param _value the max amount they can spend\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n\t\tallowance[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set allowance for other address and notify\n\t *\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n\t *\n\t * @param _spender The address authorized to spend\n\t * @param _value the max amount they can spend\n\t * @param _extraData some extra information to send to the approved contract\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n\t\ttokenRecipient spender = tokenRecipient(_spender);\n\t\tif (approve(_spender, _value)) {\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Destroy tokens\n\t *\n\t * Remove `_value` tokens from the system irreversibly\n\t *\n\t * @param _value the amount of money to burn\n\t */\n\tfunction burn(uint256 _value) public returns (bool success) {\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\n\t\ttotalSupply -= _value;                      // Updates totalSupply\n\t\temit Burn(msg.sender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Destroy tokens from other account\n\t *\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n\t *\n\t * @param _from the address of the sender\n\t * @param _value the amount of money to burn\n\t */\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n\t\ttotalSupply -= _value;                              // Update totalSupply\n\t\temit Burn(_from, _value);\n\t\treturn true;\n\t}\n}\n\n\n/**\n * @title TAO\n */\ncontract TAO {\n\tusing SafeMath for uint256;\n\n\taddress public vaultAddress;\n\tstring public name;\t\t\t\t// the name for this TAO\n\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it's the eth address\n\n\t// TAO's data\n\tstring public datHash;\n\tstring public database;\n\tstring public keyValue;\n\tbytes32 public contentId;\n\n\t/**\n\t * 0 = TAO\n\t * 1 = Name\n\t */\n\tuint8 public typeId;\n\n\t/**\n\t * @dev Constructor function\n\t */\n\tconstructor (string memory _name,\n\t\taddress _originId,\n\t\tstring memory _datHash,\n\t\tstring memory _database,\n\t\tstring memory _keyValue,\n\t\tbytes32 _contentId,\n\t\taddress _vaultAddress\n\t) public {\n\t\tname = _name;\n\t\toriginId = _originId;\n\t\tdatHash = _datHash;\n\t\tdatabase = _database;\n\t\tkeyValue = _keyValue;\n\t\tcontentId = _contentId;\n\n\t\t// Creating TAO\n\t\ttypeId = 0;\n\n\t\tvaultAddress = _vaultAddress;\n\t}\n\n\t/**\n\t * @dev Checks if calling address is Vault contract\n\t */\n\tmodifier onlyVault {\n\t\trequire (msg.sender == vaultAddress);\n\t\t_;\n\t}\n\n\t/**\n\t * Will receive any ETH sent\n\t */\n\tfunction () external payable {\n\t}\n\n\t/**\n\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\n\t * @param _recipient The recipient address\n\t * @param _amount The amount to transfer\n\t * @return true on success\n\t */\n\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyVault returns (bool) {\n\t\t_recipient.transfer(_amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\n\t * @param _erc20TokenAddress The address of ERC20 Token\n\t * @param _recipient The recipient address\n\t * @param _amount The amount to transfer\n\t * @return true on success\n\t */\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\n\t\t_erc20.transfer(_recipient, _amount);\n\t\treturn true;\n\t}\n}\n\n\n\n\n/**\n * @title Name\n */\ncontract Name is TAO {\n\t/**\n\t * @dev Constructor function\n\t */\n\tconstructor (string memory _name, address _originId, string memory _datHash, string memory _database, string memory _keyValue, bytes32 _contentId, address _vaultAddress)\n\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\n\t\t// Creating Name\n\t\ttypeId = 1;\n\t}\n}\n\n\n\n\n/**\n * @title AOLibrary\n */\nlibrary AOLibrary {\n\tusing SafeMath for uint256;\n\n\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\n\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\n\n\t/**\n\t * @dev Check whether or not the given TAO ID is a TAO\n\t * @param _taoId The ID of the TAO\n\t * @return true if yes. false otherwise\n\t */\n\tfunction isTAO(address _taoId) public view returns (bool) {\n\t\treturn (_taoId != address(0) && bytes(TAO(address(uint160(_taoId))).name()).length > 0 && TAO(address(uint160(_taoId))).originId() != address(0) && TAO(address(uint160(_taoId))).typeId() == 0);\n\t}\n\n\t/**\n\t * @dev Check whether or not the given Name ID is a Name\n\t * @param _nameId The ID of the Name\n\t * @return true if yes. false otherwise\n\t */\n\tfunction isName(address _nameId) public view returns (bool) {\n\t\treturn (_nameId != address(0) && bytes(TAO(address(uint160(_nameId))).name()).length > 0 && Name(address(uint160(_nameId))).originId() != address(0) && Name(address(uint160(_nameId))).typeId() == 1);\n\t}\n\n\t/**\n\t * @dev Check if `_tokenAddress` is a valid ERC20 Token address\n\t * @param _tokenAddress The ERC20 Token address to check\n\t */\n\tfunction isValidERC20TokenAddress(address _tokenAddress) public view returns (bool) {\n\t\tif (_tokenAddress == address(0)) {\n\t\t\treturn false;\n\t\t}\n\t\tTokenERC20 _erc20 = TokenERC20(_tokenAddress);\n\t\treturn (_erc20.totalSupply() >= 0 && bytes(_erc20.name()).length > 0 && bytes(_erc20.symbol()).length > 0);\n\t}\n\n\t/**\n\t * @dev Checks if the calling contract address is The AO\n\t *\t\tOR\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n\t * @param _sender The address to check\n\t * @param _theAO The AO address\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n\t * @return true if yes, false otherwise\n\t */\n\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\n\t\treturn (_sender == _theAO ||\n\t\t\t(\n\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\n\t\t\t\t_nameTAOPositionAddress != address(0) &&\n\t\t\t\tINameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Return the divisor used to correctly calculate percentage.\n\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\n\t *\t\tso 1% is 10000, 1.25% is 12500, etc\n\t */\n\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\n\t\treturn _PERCENTAGE_DIVISOR;\n\t}\n\n\t/**\n\t * @dev Return the divisor used to correctly calculate multiplier.\n\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\n\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\n\t */\n\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\n\t\treturn _MULTIPLIER_DIVISOR;\n\t}\n\n\t/**\n\t * @dev deploy a TAO\n\t * @param _name The name of the TAO\n\t * @param _originId The Name ID the creates the TAO\n\t * @param _datHash The datHash of this TAO\n\t * @param _database The database for this TAO\n\t * @param _keyValue The key/value pair to be checked on the database\n\t * @param _contentId The contentId related to this TAO\n\t * @param _nameTAOVaultAddress The address of NameTAOVault\n\t */\n\tfunction deployTAO(string memory _name,\n\t\taddress _originId,\n\t\tstring memory _datHash,\n\t\tstring memory _database,\n\t\tstring memory _keyValue,\n\t\tbytes32 _contentId,\n\t\taddress _nameTAOVaultAddress\n\t\t) public returns (TAO _tao) {\n\t\t_tao = new TAO(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\n\t}\n\n\t/**\n\t * @dev deploy a Name\n\t * @param _name The name of the Name\n\t * @param _originId The eth address the creates the Name\n\t * @param _datHash The datHash of this Name\n\t * @param _database The database for this Name\n\t * @param _keyValue The key/value pair to be checked on the database\n\t * @param _contentId The contentId related to this Name\n\t * @param _nameTAOVaultAddress The address of NameTAOVault\n\t */\n\tfunction deployName(string memory _name,\n\t\taddress _originId,\n\t\tstring memory _datHash,\n\t\tstring memory _database,\n\t\tstring memory _keyValue,\n\t\tbytes32 _contentId,\n\t\taddress _nameTAOVaultAddress\n\t\t) public returns (Name _myName) {\n\t\t_myName = new Name(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\n\t}\n\n\t/**\n\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n\t * @param _currentPrimordialBalance Account's current primordial ion balance\n\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\n\t * @param _additionalPrimordialAmount The primordial ion amount to be added\n\t * @return the new primordial weighted multiplier\n\t */\n\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\n\t\tif (_currentWeightedMultiplier > 0) {\n\t\t\tuint256 _totalWeightedIons = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\n\t\t\tuint256 _totalIons = _currentPrimordialBalance.add(_additionalPrimordialAmount);\n\t\t\treturn _totalWeightedIons.div(_totalIons);\n\t\t} else {\n\t\t\treturn _additionalWeightedMultiplier;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculate the primordial ion multiplier on a given lot\n\t *\t\tTotal Primordial Mintable = T\n\t *\t\tTotal Primordial Minted = M\n\t *\t\tStarting Multiplier = S\n\t *\t\tEnding Multiplier = E\n\t *\t\tTo Purchase = P\n\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\n\t *\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n\t * @param _totalPrimordialMintable Total Primordial ion mintable\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\n\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\n\t * @return The multiplier in (10 ** 6)\n\t */\n\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n\t\t\t/**\n\t\t\t * Let temp = M + (P/2)\n\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\n\t\t\t */\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n\n\t\t\t/**\n\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\n\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\n\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\n\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\n\t\t\t */\n\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\n\t\t\t/**\n\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\n\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\n\t\t\t */\n\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculate the bonus percentage of network ion on a given lot\n\t *\t\tTotal Primordial Mintable = T\n\t *\t\tTotal Primordial Minted = M\n\t *\t\tStarting Network Bonus Multiplier = Bs\n\t *\t\tEnding Network Bonus Multiplier = Be\n\t *\t\tTo Purchase = P\n\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\n\t *\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n\t * @param _totalPrimordialMintable Total Primordial ion intable\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n\t * @param _startingMultiplier The starting Network ion bonus multiplier\n\t * @param _endingMultiplier The ending Network ion bonus multiplier\n\t * @return The bonus percentage\n\t */\n\tfunction calculateNetworkBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n\t\t\t/**\n\t\t\t * Let temp = M + (P/2)\n\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\n\t\t\t */\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n\n\t\t\t/**\n\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\n\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\n\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\n\t\t\t */\n\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\n\t\t\treturn bonusPercentage;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculate the bonus amount of network ion on a given lot\n\t *\t\tAO Bonus Amount = B% x P\n\t *\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n\t * @param _totalPrimordialMintable Total Primordial ion intable\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n\t * @param _startingMultiplier The starting Network ion bonus multiplier\n\t * @param _endingMultiplier The ending Network ion bonus multiplier\n\t * @return The bonus percentage\n\t */\n\tfunction calculateNetworkBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n\t\tuint256 bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\n\t\t/**\n\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\n\t\t * when calculating the network ion bonus amount\n\t\t */\n\t\tuint256 networkBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\n\t\treturn networkBonus;\n\t}\n\n\t/**\n\t * @dev Calculate the maximum amount of Primordial an account can burn\n\t *\t\t_primordialBalance = P\n\t *\t\t_currentWeightedMultiplier = M\n\t *\t\t_maximumMultiplier = S\n\t *\t\t_amountToBurn = B\n\t *\t\tB = ((S x P) - (P x M)) / S\n\t *\n\t * @param _primordialBalance Account's primordial ion balance\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n\t * @param _maximumMultiplier The maximum multiplier of this account\n\t * @return The maximum burn amount\n\t */\n\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\n\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\n\t}\n\n\t/**\n\t * @dev Calculate the new multiplier after burning primordial ion\n\t *\t\t_primordialBalance = P\n\t *\t\t_currentWeightedMultiplier = M\n\t *\t\t_amountToBurn = B\n\t *\t\t_newMultiplier = E\n\t *\t\tE = (P x M) / (P - B)\n\t *\n\t * @param _primordialBalance Account's primordial ion balance\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n\t * @param _amountToBurn The amount of primordial ion to burn\n\t * @return The new multiplier\n\t */\n\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\n\t}\n\n\t/**\n\t * @dev Calculate the new multiplier after converting network ion to primordial ion\n\t *\t\t_primordialBalance = P\n\t *\t\t_currentWeightedMultiplier = M\n\t *\t\t_amountToConvert = C\n\t *\t\t_newMultiplier = E\n\t *\t\tE = (P x M) / (P + C)\n\t *\n\t * @param _primordialBalance Account's primordial ion balance\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n\t * @param _amountToConvert The amount of network ion to convert\n\t * @return The new multiplier\n\t */\n\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\n\t}\n\n\t/**\n\t * @dev count num of digits\n\t * @param number uint256 of the nuumber to be checked\n\t * @return uint8 num of digits\n\t */\n\tfunction numDigits(uint256 number) public pure returns (uint8) {\n\t\tuint8 digits = 0;\n\t\twhile(number != 0) {\n\t\t\tnumber = number.div(10);\n\t\t\tdigits++;\n\t\t}\n\t\treturn digits;\n\t}\n}\n\n\n\ncontract TheAO {\n\taddress public theAO;\n\taddress public nameTAOPositionAddress;\n\n\t// Check whether an address is whitelisted and granted access to transact\n\t// on behalf of others\n\tmapping (address => bool) public whitelist;\n\n\tconstructor() public {\n\t\ttheAO = msg.sender;\n\t}\n\n\t/**\n\t * @dev Checks if msg.sender is in whitelist.\n\t */\n\tmodifier inWhitelist() {\n\t\trequire (whitelist[msg.sender] == true);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Transfer ownership of The AO to new address\n\t * @param _theAO The new address to be transferred\n\t */\n\tfunction transferOwnership(address _theAO) public {\n\t\trequire (msg.sender == theAO);\n\t\trequire (_theAO != address(0));\n\t\ttheAO = _theAO;\n\t}\n\n\t/**\n\t * @dev Whitelist `_account` address to transact on behalf of others\n\t * @param _account The address to whitelist\n\t * @param _whitelist Either to whitelist or not\n\t */\n\tfunction setWhitelist(address _account, bool _whitelist) public {\n\t\trequire (msg.sender == theAO);\n\t\trequire (_account != address(0));\n\t\twhitelist[_account] = _whitelist;\n\t}\n}\n\n\n/**\n * @title TAOCurrency\n */\ncontract TAOCurrency is TheAO {\n\tusing SafeMath for uint256;\n\n\t// Public variables of the contract\n\tstring public name;\n\tstring public symbol;\n\tuint8 public decimals;\n\n\t// To differentiate denomination of TAO Currency\n\tuint256 public powerOfTen;\n\n\tuint256 public totalSupply;\n\n\t// This creates an array with all balances\n\t// address is the address of nameId, not the eth public address\n\tmapping (address => uint256) public balanceOf;\n\n\t// This generates a public event on the blockchain that will notify clients\n\t// address is the address of TAO/Name Id, not eth public address\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t// This notifies clients about the amount burnt\n\t// address is the address of TAO/Name Id, not eth public address\n\tevent Burn(address indexed from, uint256 value);\n\n\t/**\n\t * Constructor function\n\t *\n\t * Initializes contract with initial supply TAOCurrency to the creator of the contract\n\t */\n\tconstructor (string memory _name, string memory _symbol, address _nameTAOPositionAddress) public {\n\t\tname = _name;\t\t// Set the name for display purposes\n\t\tsymbol = _symbol;\t// Set the symbol for display purposes\n\n\t\tpowerOfTen = 0;\n\t\tdecimals = 0;\n\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\n\t}\n\n\t/**\n\t * @dev Checks if the calling contract address is The AO\n\t *\t\tOR\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n\t */\n\tmodifier onlyTheAO {\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Check if `_id` is a Name or a TAO\n\t */\n\tmodifier isNameOrTAO(address _id) {\n\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\n\t\t_;\n\t}\n\n\t/***** The AO ONLY METHODS *****/\n\t/**\n\t * @dev Transfer ownership of The AO to new address\n\t * @param _theAO The new address to be transferred\n\t */\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\n\t\trequire (_theAO != address(0));\n\t\ttheAO = _theAO;\n\t}\n\n\t/**\n\t * @dev Whitelist `_account` address to transact on behalf of others\n\t * @param _account The address to whitelist\n\t * @param _whitelist Either to whitelist or not\n\t */\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n\t\trequire (_account != address(0));\n\t\twhitelist[_account] = _whitelist;\n\t}\n\n\t/**\n\t * @dev The AO set the NameTAOPosition Address\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n\t */\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n\t\trequire (_nameTAOPositionAddress != address(0));\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n\t}\n\n\t/***** PUBLIC METHODS *****/\n\t/**\n\t * @dev transfer TAOCurrency from other address\n\t *\n\t * Send `_value` TAOCurrency to `_to` in behalf of `_from`\n\t *\n\t * @param _from The address of the sender\n\t * @param _to The address of the recipient\n\t * @param _value the amount to send\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public inWhitelist isNameOrTAO(_from) isNameOrTAO(_to) returns (bool) {\n\t\t_transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Create `mintedAmount` TAOCurrency and send it to `target`\n\t * @param target Address to receive TAOCurrency\n\t * @param mintedAmount The amount of TAOCurrency it will receive\n\t * @return true on success\n\t */\n\tfunction mint(address target, uint256 mintedAmount) public inWhitelist isNameOrTAO(target) returns (bool) {\n\t\t_mint(target, mintedAmount);\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @dev Whitelisted address remove `_value` TAOCurrency from the system irreversibly on behalf of `_from`.\n\t *\n\t * @param _from the address of the sender\n\t * @param _value the amount of money to burn\n\t */\n\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist isNameOrTAO(_from) returns (bool success) {\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\n\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\n\t\temit Burn(_from, _value);\n\t\treturn true;\n\t}\n\n\t/***** INTERNAL METHODS *****/\n\t/**\n\t * @dev Send `_value` TAOCurrency from `_from` to `_to`\n\t * @param _from The address of sender\n\t * @param _to The address of the recipient\n\t * @param _value The amount to send\n\t */\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\n\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\n\t\temit Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n\t}\n\n\t/**\n\t * @dev Create `mintedAmount` TAOCurrency and send it to `target`\n\t * @param target Address to receive TAOCurrency\n\t * @param mintedAmount The amount of TAOCurrency it will receive\n\t */\n\tfunction _mint(address target, uint256 mintedAmount) internal {\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\n\t\ttotalSupply = totalSupply.add(mintedAmount);\n\t\temit Transfer(address(0), address(this), mintedAmount);\n\t\temit Transfer(address(this), target, mintedAmount);\n\t}\n}\n\n\ncontract LogosExa is TAOCurrency {\n\t/**\n\t * @dev Constructor function\n\t */\n\tconstructor(string memory _name, string memory _symbol, address _nameTAOPositionAddress)\n\t\tTAOCurrency(_name, _symbol, _nameTAOPositionAddress) public {\n\t\tpowerOfTen = 18;\n\t\tdecimals = 18;\n\t}\n}"
}