{
  "timeline_sequence": [],
  "sourcecode": "pragma solidity 0.5.7;\n\n\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingOwner.\n     */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Allows the current owner to set the pendingOwner address.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) onlyOwner public {\n        pendingOwner = newOwner;\n    }\n\n    /**\n     * @dev Allows the pendingOwner address to finalize the transfer.\n     */\n    function claimOwnership() onlyPendingOwner public {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\n\ncontract FastnFurious is Ownable {\n    using SafeMath for uint;\n    \n    // round => winner\n    mapping(uint => address payable) public winners;\n    \n    // round => gain\n    mapping(uint => uint) public balances;\n    \n    uint public minBet = 0.1 ether; // 0.1 ether;\n    \n    uint public startTime = 1554076800; // 04.01.2019 00:00:00\n    uint public roundTime = 60; // 1 min in sec\n    \n    address payable public wallet;\n    address payable public jackpot;\n    \n    mapping (uint => uint) public pool;\n    \n    uint public walletPercent = 20;\n    uint public nextRoundPercent = 15;\n    uint public jackpotPercent = 15;\n    uint public lastRound;\n        \n    constructor (address payable _wallet, address payable _jackpot) public {\n        require(_wallet != address(0));\n        require(_jackpot != address(0));\n        \n    \twallet = _wallet;\n    \tjackpot = _jackpot;  \n    }\n    \n    function () external payable {\n        require(gasleft() > 150000);\n        setBet(msg.sender);\n    }\n    \n    function setBet(address payable _player) public payable {\n        require(msg.value >= minBet);\n        \n        uint currentRound = getCurrentRound();\n        \n        if (currentRound > 1 && balances[currentRound] == 0) {\n            uint gain = balances[lastRound];\n        \tbalances[lastRound] = 0;\n        \tbalances[currentRound] = balances[currentRound].add(pool[lastRound]);\n    \n            address payable winner = getWinner(lastRound); \n            winner.transfer(gain);\n        }\n        \n        lastRound = currentRound;\n        \n        uint amount = msg.value;\n        uint toWallet = amount.mul(walletPercent).div(100);\n        uint toNextRound = amount.mul(nextRoundPercent).div(100);\n        uint toJackpot = amount.mul(jackpotPercent).div(100);\n\n        winners[currentRound] = _player;\n        \n        balances[currentRound] = balances[currentRound].add(amount).sub(toWallet).sub(toNextRound).sub(toJackpot);\n        pool[currentRound] = pool[currentRound].add(toNextRound);\n        \n        jackpot.transfer(toJackpot);\n        wallet.transfer(toWallet);\n    }\n    \n    function getWinner(uint _round) public view returns (address payable) {\n        if (winners[_round] != address(0)) return winners[_round];\n        else return wallet;\n    }\n\n    function changeRoundTime(uint _time) onlyOwner public {\n        roundTime = _time;\n    }\n    \n    function changeStartTime(uint _time) onlyOwner public {\n        startTime = _time;    \n    }\n    \n    function changeWallet(address payable _wallet) onlyOwner public {\n        wallet = _wallet;\n    }\n\n    function changeJackpot(address payable _jackpot) onlyOwner public {\n        jackpot = _jackpot;\n    }\n    \n    function changeMinimalBet(uint _minBet) onlyOwner public {\n        minBet = _minBet;\n    }\n    \n    function changePercents(uint _toWinner, uint _toNextRound, uint _toWallet, uint _toJackPot) onlyOwner public {\n        uint total = _toWinner.add(_toNextRound).add(_toWallet).add(_toJackPot);\n        require(total == 100);\n        \n        walletPercent = _toWallet;\n        nextRoundPercent = _toNextRound;\n        jackpotPercent = _toJackPot;\n    }\n    \n    function getCurrentRound() public view returns (uint) {\n        return now.sub(startTime).div(roundTime).add(1); // start round is 1\n    }\n    \n    function getPreviosRound() public view returns (uint) {\n        return getCurrentRound().sub(1);    \n    }\n    \n    function getRoundBalance(uint _round) public view returns (uint) {\n        return balances[_round];\n    }\n    \n    function getPoolBalance(uint _round) public view returns (uint) {\n        return pool[_round];\n    }\n    \n    function getRoundByTime(uint _time) public view returns (uint) {\n        return _time.sub(startTime).div(roundTime);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}"
}