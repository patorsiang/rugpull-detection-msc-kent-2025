{
  "opcode_sequence": "PUSH1 PUSH1 MSTORE PUSH1 CALLDATASIZE LT PUSH2 JUMPI PUSH4 PUSH29 PUSH1 CALLDATALOAD DIV AND PUSH4 DUP2 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI DUP1 PUSH4 EQ PUSH2 JUMPI JUMPDEST PUSH1 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 MLOAD SWAP1 DUP2 MSTORE PUSH1 ADD PUSH1 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 MLOAD DUP1 DUP3 PUSH1 DUP2 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST PUSH1 AND DUP2 MSTORE PUSH1 ADD SWAP2 POP POP PUSH1 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 ADD PUSH1 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 CALLDATALOAD PUSH2 JUMP JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 CALLDATALOAD PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 CALLDATALOAD PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH1 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE PUSH1 ADD PUSH1 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 PUSH16 PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST CALLVALUE ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB PUSH1 CALLDATALOAD AND PUSH2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH1 SWAP1 PUSH1 AND ISZERO PUSH2 JUMPI POP PUSH1 PUSH2 JUMP JUMPDEST PUSH1 SLOAD ISZERO ISZERO PUSH2 JUMPI PUSH1 SLOAD TIMESTAMP LT PUSH2 JUMPI POP PUSH1 PUSH2 JUMP JUMPDEST POP PUSH1 PUSH2 JUMP JUMPDEST POP PUSH1 JUMPDEST SWAP1 JUMP JUMPDEST PUSH1 SLOAD PUSH1 SWAP1 PUSH2 SWAP1 DIV PUSH1 PUSH1 PUSH1 EXP SUB AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 SLOAD PUSH2 SWAP1 DIV PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH4 PUSH1 PUSH1 MLOAD PUSH1 ADD MSTORE PUSH1 MLOAD DUP2 PUSH4 AND PUSH29 MUL DUP2 MSTORE PUSH1 ADD PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 DUP8 DUP1 EXTCODESIZE ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 GAS SUB CALL ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP POP POP PUSH1 MLOAD DUP1 MLOAD SWAP2 POP POP SWAP1 JUMP JUMPDEST PUSH1 PUSH1 MSTORE PUSH1 SWAP1 DUP2 MSTORE PUSH1 SWAP1 SHA3 SLOAD DUP2 JUMP JUMPDEST PUSH1 DUP1 SLOAD PUSH21 SWAP1 DIV PUSH1 AND ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 SLOAD TIMESTAMP GT PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP CALLER DUP2 ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST DUP2 PUSH2 DUP3 PUSH2 JUMP JUMPDEST LT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 SLOAD PUSH1 ADD SWAP1 SSTORE JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD PUSH2 SWAP1 DUP4 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP3 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SSTORE PUSH1 SLOAD PUSH2 SWAP1 DUP4 PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 SSTORE PUSH2 PUSH2 JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH4 DUP3 DUP5 PUSH1 PUSH1 MLOAD PUSH1 ADD MSTORE PUSH1 MLOAD PUSH29 PUSH4 DUP6 AND MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP3 AND PUSH1 DUP4 ADD MSTORE PUSH1 DUP3 ADD MSTORE PUSH1 ADD PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 DUP8 DUP1 EXTCODESIZE ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 GAS SUB CALL ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP POP POP PUSH1 MLOAD DUP1 MLOAD SWAP1 POP POP PUSH32 DUP2 DUP4 PUSH1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP3 AND DUP3 MSTORE PUSH1 DUP3 ADD MSTORE PUSH1 SWAP1 DUP2 ADD SWAP1 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 POP POP JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP2 SHA3 SLOAD PUSH2 SWAP1 PUSH2 DUP5 PUSH2 JUMP JUMPDEST SWAP1 PUSH4 PUSH2 AND JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 DUP1 SLOAD DUP3 SWAP1 DUP2 LT PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST PUSH1 SWAP2 DUP3 MSTORE PUSH1 SWAP1 SWAP2 SHA3 ADD SLOAD PUSH1 PUSH1 PUSH1 EXP SUB AND SWAP1 POP DUP2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH21 NOT AND PUSH2 PUSH1 PUSH1 PUSH1 EXP SUB DUP5 DUP2 AND DUP3 MUL SWAP3 SWAP1 SWAP3 OR SWAP3 DUP4 SWAP1 SSTORE SWAP1 SWAP2 DIV AND PUSH4 PUSH1 PUSH1 MLOAD PUSH1 ADD MSTORE PUSH1 MLOAD DUP2 PUSH4 AND PUSH29 MUL DUP2 MSTORE PUSH1 ADD PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 DUP8 DUP1 EXTCODESIZE ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 GAS SUB CALL ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP POP POP PUSH1 MLOAD DUP1 MLOAD POP POP JUMPDEST POP JUMP JUMPDEST PUSH1 DUP1 SLOAD DUP2 SWAP1 PUSH21 SWAP1 DIV PUSH1 AND ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP2 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST CALLER PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD SWAP1 SWAP3 POP ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND PUSH1 DUP2 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP1 DUP3 SHA3 DUP1 SLOAD SWAP3 SWAP1 SSTORE SWAP1 SWAP2 SWAP1 DUP3 SWAP1 MLOAD PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP8 PUSH2 GAS SUB CALL SWAP3 POP POP POP ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH32 DUP3 DUP3 PUSH1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP3 AND DUP3 MSTORE PUSH1 DUP3 ADD MSTORE PUSH1 SWAP1 DUP2 ADD SWAP1 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 POP POP JUMP JUMPDEST PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 SSTORE JUMP JUMPDEST PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH21 NOT AND PUSH21 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP2 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 JUMP JUMPDEST PUSH1 SWAP1 JUMP JUMPDEST PUSH1 SLOAD PUSH21 SWAP1 DIV PUSH1 AND ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 DUP2 PUSH2 JUMP JUMPDEST PUSH1 SLOAD PUSH2 SWAP1 DIV PUSH1 PUSH1 PUSH1 EXP SUB AND DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH21 SWAP1 DIV PUSH1 AND ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 PUSH1 PUSH2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH21 SWAP1 DIV PUSH1 AND DUP2 JUMP JUMPDEST PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH1 NOT AND PUSH1 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 PUSH1 MSTORE PUSH1 SWAP1 DUP2 MSTORE PUSH1 SWAP1 SHA3 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 SLOAD PUSH21 SWAP1 DIV PUSH1 AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH21 NOT AND SWAP1 SSTORE JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH2 PUSH2 CALLER PUSH2 JUMP JUMPDEST PUSH2 JUMP JUMPDEST PUSH1 SLOAD PUSH21 SWAP1 DIV PUSH1 AND DUP1 ISZERO PUSH2 JUMPI POP PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ ISZERO JUMPDEST ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP2 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 SLOAD PUSH2 SWAP1 DIV PUSH1 PUSH1 PUSH1 EXP SUB AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 SWAP1 SLOAD SWAP1 PUSH2 EXP SWAP1 DIV PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH4 PUSH1 SLOAD ADDRESS PUSH1 MLOAD PUSH29 PUSH4 DUP6 AND MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP2 AND PUSH1 DUP3 ADD MSTORE PUSH1 ADD PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP1 EXTCODESIZE ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 GAS SUB CALL ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP POP POP POP PUSH2 PUSH2 JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB AND PUSH4 ADDRESS PUSH1 PUSH1 MLOAD PUSH1 ADD MSTORE PUSH1 MLOAD PUSH29 PUSH4 DUP5 AND MUL DUP2 MSTORE PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP2 AND PUSH1 DUP3 ADD MSTORE PUSH1 ADD PUSH1 PUSH1 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 DUP8 DUP1 EXTCODESIZE ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH2 GAS SUB CALL ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP POP POP PUSH1 MLOAD DUP1 MLOAD PUSH1 DUP2 SWAP1 SSTORE ISZERO ISZERO SWAP1 POP PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH32 PUSH1 SLOAD PUSH1 MLOAD SWAP1 DUP2 MSTORE PUSH1 ADD PUSH1 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD DUP2 JUMP JUMPDEST PUSH1 SLOAD PUSH1 AND DUP2 JUMP JUMPDEST PUSH1 PUSH1 PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP2 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 SLOAD PUSH1 SLOAD PUSH1 PUSH1 PUSH1 EXP SUB DUP5 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD PUSH2 SWAP2 PUSH4 PUSH2 AND JUMP JUMPDEST DUP2 ISZERO ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST DIV SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 SLOAD CALLER PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 DUP2 AND SWAP2 AND EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH1 DUP1 SLOAD PUSH20 NOT AND PUSH1 PUSH1 PUSH1 EXP SUB SWAP3 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 DUP3 DUP3 ADD DUP4 DUP2 LT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 DUP3 DUP3 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST POP SWAP1 SUB SWAP1 JUMP JUMPDEST PUSH1 DUP1 PUSH1 PUSH2 PUSH2 JUMP JUMPDEST PUSH1 DUP2 GT ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST EQ PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST CALLVALUE ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST POP POP CALLER PUSH1 PUSH1 PUSH1 EXP SUB DUP2 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 DUP2 SHA3 SLOAD SWAP1 DUP2 GT SWAP1 PUSH2 SWAP1 CALLVALUE PUSH2 JUMP JUMPDEST PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 DUP2 SWAP1 SSTORE PUSH1 SLOAD SWAP1 LT DUP1 PUSH2 JUMPI POP PUSH1 SLOAD PUSH1 PUSH1 PUSH1 EXP SUB DUP4 AND PUSH1 SWAP1 DUP2 MSTORE PUSH1 PUSH1 MSTORE PUSH1 SWAP1 SHA3 SLOAD GT JUMPDEST ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST DUP1 ISZERO ISZERO PUSH2 JUMPI PUSH1 DUP1 SLOAD PUSH1 DUP2 ADD PUSH2 DUP4 DUP3 PUSH2 JUMP JUMPDEST POP PUSH1 SWAP2 DUP3 MSTORE PUSH1 SWAP1 SWAP2 SHA3 ADD DUP1 SLOAD PUSH20 NOT AND PUSH1 PUSH1 PUSH1 EXP SUB DUP5 AND OR SWAP1 SSTORE PUSH1 DUP1 SLOAD DUP2 ADD SWAP1 SSTORE JUMPDEST PUSH1 SLOAD PUSH2 SWAP1 CALLVALUE PUSH4 PUSH2 AND JUMP JUMPDEST PUSH1 DUP2 SWAP1 SSTORE PUSH1 SLOAD SWAP1 GT ISZERO PUSH2 JUMPI PUSH1 DUP1 REVERT JUMPDEST PUSH32 DUP3 CALLVALUE DUP6 PUSH1 MLOAD PUSH1 PUSH1 PUSH1 EXP SUB SWAP1 SWAP4 AND DUP4 MSTORE PUSH1 DUP4 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH16 AND PUSH1 DUP1 DUP4 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH1 SWAP1 SWAP2 ADD SWAP1 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 POP POP POP JUMP JUMPDEST PUSH1 DUP3 DUP3 MUL DUP4 ISZERO DUP1 PUSH2 JUMPI POP DUP3 DUP5 DUP3 DUP2 ISZERO ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST DIV EQ JUMPDEST ISZERO ISZERO PUSH2 JUMPI UNKNOWN_0xfe JUMPDEST DUP2 SLOAD DUP2 DUP4 SSTORE DUP2 DUP2 ISZERO GT PUSH2 JUMPI PUSH1 DUP4 DUP2 MSTORE PUSH1 SWAP1 SHA3 PUSH2 SWAP2 DUP2 ADD SWAP1 DUP4 ADD PUSH2 JUMP JUMPDEST POP POP POP JUMP JUMPDEST PUSH2 SWAP2 SWAP1 JUMPDEST DUP1 DUP3 GT ISZERO PUSH2 JUMPI PUSH1 DUP2 SSTORE PUSH1 ADD PUSH2 JUMP JUMPDEST POP SWAP1 JUMP STOP LOG1 PUSH6 SHA3 SWAP14 DUP3 GAS UNKNOWN_0xd SHR UNKNOWN_0xfb UNKNOWN_0xc4 UNKNOWN_0x4e PUSH7 UNKNOWN_0xe4 GASLIMIT UNKNOWN_0xeb EQ LOG1 SAR RETURN SWAP4 DUP5 INVALID_0x77",
  "opcode_entropy": 4.641270041735956,
  "opcode_count": 2562,
  "unique_opcodes": 68,
  "byte_entropy": 5.697752355742064,
  "byte_60": 0.10255231087606347,
  "byte_40": 0.011956771671648655,
  "byte_52": 0.012416647505173604,
  "byte_04": 0.014716026672798345,
  "byte_36": 0.0006898137502874224,
  "byte_10": 0.004138882501724534,
  "byte_61": 0.06001379627500575,
  "byte_01": 0.02989192917912164,
  "byte_b6": 0.0009197516670498966,
  "byte_57": 0.02989192917912164,
  "byte_63": 0.011956771671648655,
  "byte_ff": 0.03541043918142102,
  "byte_7c": 0.0013796275005748448,
  "byte_00": 0.11588871004828696,
  "byte_35": 0.0032191308346746377,
  "byte_16": 0.018624971257760404,
  "byte_15": 0.024833295010347207,
  "byte_fe": 0.00390894458496206,
  "byte_22": 0.0004598758335249483,
  "byte_81": 0.022303977925959992,
  "byte_14": 0.011266957921361233,
  "byte_bb": 0.0009197516670498966,
  "byte_80": 0.03495056334789607,
  "byte_18": 0.0009197516670498966,
  "byte_65": 0.0011496895838123706,
  "byte_c5": 0.0004598758335249483,
  "byte_7d": 0.0011496895838123706,
  "byte_e0": 0.0004598758335249483,
  "byte_21": 0.0004598758335249483,
  "byte_df": 0.0006898137502874224,
  "byte_0d": 0.004368820418487009,
  "byte_a7": 0.0004598758335249483,
  "byte_02": 0.02276385375948494,
  "byte_17": 0.0018395033340997931,
  "byte_27": 0.0006898137502874224,
  "byte_e2": 0.0013796275005748448,
  "byte_e3": 0.0011496895838123706,
  "byte_46": 0.0013796275005748448,
  "byte_37": 0.0006898137502874224,
  "byte_96": 0.0004598758335249483,
  "byte_07": 0.004138882501724534,
  "byte_f5": 0.0006898137502874224,
  "byte_3c": 0.00022993791676247414,
  "byte_67": 0.00022993791676247414,
  "byte_b7": 0.00022993791676247414,
  "byte_3f": 0.0004598758335249483,
  "byte_eb": 0.0006898137502874224,
  "byte_5f": 0.0004598758335249483,
  "byte_2b": 0.0006898137502874224,
  "byte_9c": 0.0011496895838123706,
  "byte_42": 0.0006898137502874224,
  "byte_6f": 0.0009197516670498966,
  "byte_b2": 0.0004598758335249483,
  "byte_48": 0.0004598758335249483,
  "byte_3a": 0.0004598758335249483,
  "byte_20": 0.01172683375488618,
  "byte_59": 0.0009197516670498966,
  "byte_0e": 0.0073580133363991725,
  "byte_1a": 0.0006898137502874224,
  "byte_e4": 0.0006898137502874224,
  "byte_5b": 0.045297769602207404,
  "byte_cb": 0.0018395033340997931,
  "byte_31": 0.0009197516670498966,
  "byte_8a": 0.0009197516670498966,
  "byte_f7": 0.0006898137502874224,
  "byte_5e": 0.0004598758335249483,
  "byte_d7": 0.0016095654173373189,
  "byte_ca": 0.0004598758335249483,
  "byte_03": 0.024603357093584733,
  "byte_69": 0.00022993791676247414,
  "byte_62": 0.0006898137502874224,
  "byte_b0": 0.0004598758335249483,
  "byte_73": 0.0009197516670498966,
  "byte_83": 0.005978385835824327,
  "byte_ac": 0.00022993791676247414,
  "byte_33": 0.0029891929179121637,
  "byte_84": 0.0025293170843872156,
  "byte_50": 0.014716026672798345,
  "byte_29": 0.0004598758335249483,
  "byte_87": 0.0025293170843872156,
  "byte_8d": 0.0006898137502874224,
  "byte_a4": 0.00022993791676247414,
  "byte_d3": 0.00022993791676247414,
  "byte_c9": 0.0004598758335249483,
  "byte_a5": 0.00022993791676247414,
  "byte_74": 0.0029891929179121637,
  "byte_95": 0.0004598758335249483,
  "byte_4a": 0.0004598758335249483,
  "byte_99": 0.0004598758335249483,
  "byte_e9": 0.00022993791676247414,
  "byte_6c": 0.0004598758335249483,
  "byte_ae": 0.0009197516670498966,
  "byte_1e": 0.0009197516670498966,
  "byte_a0": 0.010807082087836284,
  "byte_a6": 0.00022993791676247414,
  "byte_f2": 0.0004598758335249483,
  "byte_de": 0.0006898137502874224,
  "byte_aa": 0.00022993791676247414,
  "byte_55": 0.004138882501724534,
  "byte_ef": 0.0006898137502874224,
  "byte_e6": 0.0004598758335249483,
  "byte_b9": 0.0004598758335249483,
  "byte_b8": 0.0011496895838123706,
  "byte_af": 0.0004598758335249483,
  "byte_0b": 0.00390894458496206,
  "byte_f9": 0.0004598758335249483,
  "byte_bd": 0.0004598758335249483,
  "byte_f8": 0.0009197516670498966,
  "byte_0c": 0.0027592550011496897,
  "byte_c8": 0.00022993791676247414,
  "byte_1f": 0.0004598758335249483,
  "byte_3e": 0.0009197516670498966,
  "byte_64": 0.0004598758335249483,
  "byte_fd": 0.017015405840423086,
  "byte_d0": 0.0004598758335249483,
  "byte_85": 0.0013796275005748448,
  "byte_5a": 0.002069441250862267,
  "byte_51": 0.010347206254311335,
  "byte_d1": 0.0004598758335249483,
  "byte_05": 0.0073580133363991725,
  "byte_8e": 0.00022993791676247414,
  "byte_d4": 0.0006898137502874224,
  "byte_70": 0.0013796275005748448,
  "byte_77": 0.0004598758335249483,
  "byte_d5": 0.00022993791676247414,
  "byte_d2": 0.0004598758335249483,
  "byte_a1": 0.0018395033340997931,
  "byte_4c": 0.0006898137502874224,
  "byte_9d": 0.0006898137502874224,
  "byte_db": 0.00022993791676247414,
  "byte_a2": 0.00022993791676247414,
  "byte_d8": 0.00022993791676247414,
  "byte_75": 0.00022993791676247414,
  "byte_dd": 0.0011496895838123706,
  "byte_e8": 0.0006898137502874224,
  "byte_c3": 0.0006898137502874224,
  "byte_8b": 0.00022993791676247414,
  "byte_34": 0.008507702920211543,
  "byte_c6": 0.0013796275005748448,
  "byte_ce": 0.0034490687514371118,
  "byte_56": 0.022993791676247412,
  "byte_90": 0.026672798344447,
  "byte_91": 0.009197516670498965,
  "byte_f3": 0.0016095654173373189,
  "byte_82": 0.00781788916992412,
  "byte_11": 0.0032191308346746377,
  "byte_2a": 0.0013796275005748448,
  "byte_0a": 0.01563577833984824,
  "byte_ea": 0.0009197516670498966,
  "byte_7b": 0.0032191308346746377,
  "byte_fc": 0.0006898137502874224,
  "byte_88": 0.0004598758335249483,
  "byte_f0": 0.0004598758335249483,
  "byte_08": 0.002069441250862267,
  "byte_e5": 0.0004598758335249483,
  "byte_09": 0.002299379167624741,
  "byte_5c": 0.0009197516670498966,
  "byte_68": 0.00022993791676247414,
  "byte_89": 0.0004598758335249483,
  "byte_7f": 0.0018395033340997931,
  "byte_8f": 0.0006898137502874224,
  "byte_92": 0.0034490687514371118,
  "byte_9a": 0.0009197516670498966,
  "byte_9e": 0.0004598758335249483,
  "byte_a3": 0.00022993791676247414,
  "byte_d6": 0.0006898137502874224,
  "byte_f1": 0.0016095654173373189,
  "byte_41": 0.0004598758335249483,
  "byte_6b": 0.0004598758335249483,
  "byte_49": 0.0004598758335249483,
  "byte_e1": 0.0004598758335249483,
  "byte_e7": 0.00022993791676247414,
  "byte_a8": 0.0006898137502874224,
  "byte_ee": 0.0004598758335249483,
  "byte_ed": 0.00022993791676247414,
  "byte_54": 0.01563577833984824,
  "byte_1d": 0.0004598758335249483,
  "byte_43": 0.0011496895838123706,
  "byte_06": 0.0029891929179121637,
  "byte_6a": 0.0004598758335249483,
  "byte_3b": 0.0013796275005748448,
  "byte_dc": 0.0004598758335249483,
  "byte_25": 0.0006898137502874224,
  "byte_4b": 0.0004598758335249483,
  "byte_b5": 0.0011496895838123706,
  "byte_a9": 0.0004598758335249483,
  "byte_24": 0.0009197516670498966,
  "byte_44": 0.0004598758335249483,
  "byte_58": 0.0009197516670498966,
  "byte_2e": 0.00022993791676247414,
  "byte_93": 0.0011496895838123706,
  "byte_12": 0.00022993791676247414,
  "byte_2f": 0.0004598758335249483,
  "byte_b1": 0.0004598758335249483,
  "byte_13": 0.0006898137502874224,
  "byte_76": 0.0004598758335249483,
  "byte_c0": 0.00022993791676247414,
  "byte_39": 0.0004598758335249483,
  "byte_19": 0.0013796275005748448,
  "byte_45": 0.0006898137502874224,
  "byte_2d": 0.00022993791676247414,
  "byte_ad": 0.00022993791676247414,
  "byte_4d": 0.00022993791676247414,
  "byte_98": 0.0004598758335249483,
  "byte_1c": 0.0004598758335249483,
  "byte_c4": 0.0009197516670498966,
  "byte_4f": 0.0004598758335249483,
  "byte_8c": 0.0006898137502874224,
  "byte_4e": 0.0004598758335249483,
  "byte_72": 0.0004598758335249483,
  "byte_c1": 0.00022993791676247414,
  "byte_c7": 0.0004598758335249483,
  "byte_30": 0.0006898137502874224,
  "byte_f4": 0.00022993791676247414,
  "byte_ab": 0.0006898137502874224,
  "byte_6e": 0.0004598758335249483,
  "byte_bc": 0.00022993791676247414,
  "byte_b3": 0.0004598758335249483,
  "byte_2c": 0.0004598758335249483,
  "byte_78": 0.00022993791676247414,
  "byte_23": 0.00022993791676247414,
  "byte_66": 0.0004598758335249483,
  "byte_71": 0.00022993791676247414,
  "byte_86": 0.00022993791676247414,
  "byte_0f": 0.0018395033340997931,
  "byte_79": 0.00022993791676247414,
  "byte_32": 0.0006898137502874224,
  "byte_5d": 0.00022993791676247414,
  "byte_f6": 0.00022993791676247414,
  "byte_1b": 0.00022993791676247414,
  "byte_97": 0.00022993791676247414,
  "byte_cd": 0.00022993791676247414,
  "byte_7a": 0.0004598758335249483,
  "byte_fb": 0.0004598758335249483,
  "byte_ba": 0.00022993791676247414,
  "byte_53": 0.00022993791676247414,
  "byte_7e": 0.00022993791676247414,
  "num_nodes": 6,
  "num_edges": 5,
  "avg_degree": 1.6666666666666667,
  "density": 0.16666666666666666,
  "connected_components": 1,
  "avg_clustering": 0.0,
  "txn_nums": 6,
  "event_nums": 5,
  "creation_block": 4725716,
  "creation_timestamp": 1513170813,
  "life_time": 149762.0,
  "duration_seconds": 2260381.0,
  "from_creation_to_transfer": 0.0,
  "num_addresses": 7,
  "num_buyers": 2,
  "num_sellers": 5,
  "num_creator_transfers": 1,
  "buy_amt": 1.97e+21,
  "sell_amt": 1.97e+21,
  "avg_value": 5.628571428571428e+20,
  "txn_per_block": 4.0063300014022156e-05,
  "avg_gas_limit": 453689.3333333333,
  "std_gas_limit": 424261.90709814563,
  "avg_gas_used": 272764.3333333333,
  "std_gas_used": 462160.7221875188,
  "avg_gas_price": 22833333333.333332,
  "std_gas_price": 13107461827.354507,
  "invested_num": 4,
  "tokensboughts_num": 1,
  "buywithcustomerid_num": 4,
  "timeline_sequence": [
    [
      4725716,
      1513170813,
      17528,
      25,
      0,
      1402249,
      30000000000,
      0,
      1,
      2158790,
      1302249,
      18395754
    ],
    [
      4812978,
      1514471898,
      41,
      109,
      1370000000000000000000,
      260300,
      21000000000,
      0,
      1,
      4972537,
      128886,
      18308492
    ],
    [
      4822400,
      1514613538,
      1,
      89,
      300000000000000000000,
      260300,
      21000000000,
      0,
      1,
      2787809,
      83886,
      18299070
    ],
    [
      4824865,
      1514650236,
      2,
      16,
      50000000000000000000,
      260300,
      21000000000,
      0,
      1,
      761124,
      37679,
      18296605
    ],
    [
      4849411,
      1515015980,
      0,
      28,
      250000000000000000000,
      260300,
      44000000000,
      0,
      1,
      1104539,
      83886,
      18272059
    ],
    [
      4875478,
      1515431194,
      0,
      0,
      1970000000000000000000,
      278687,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "sourcecode": "/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n/**\n * Safe unsigned safe math.\n *\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\n *\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\n *\n * Maintained here until merged to mainline zeppelin-solidity.\n *\n */\nlibrary SafeMathLib {\n\n  function times(uint a, uint b) returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function minus(uint a, uint b) returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) returns (uint) {\n    uint c = a + b;\n    assert(c>=a);\n    return c;\n  }\n\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n/**\n * Interface for defining crowdsale pricing.\n */\ncontract PricingStrategy {\n\n  /** Interface declaration. */\n  function isPricingStrategy() public constant returns (bool) {\n    return true;\n  }\n\n  /** Self check if all references are correctly set.\n   *\n   * Checks that pricing strategy matches crowdsale parameters.\n   */\n  function isSane(address crowdsale) public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Pricing tells if this is a presale purchase or not.\n     @param purchaser Address of the purchaser\n     @return False by default, true if a presale purchaser\n   */\n  function isPresalePurchase(address purchaser) public constant returns (bool) {\n    return false;\n  }\n\n  /**\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\n   *\n   *\n   * @param value - What is the value of the transaction send in as wei\n   * @param tokensSold - how much tokens have been sold this far\n   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale\n   * @param msgSender - who is the investor of this transaction\n   * @param decimals - how many decimal units the token has\n   * @return Amount of tokens the investor receives\n   */\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n/**\n * Finalize agent defines what happens at the end of succeseful crowdsale.\n *\n * - Allocate tokens for founders, bounties and community\n * - Make tokens transferable\n * - etc.\n */\ncontract FinalizeAgent {\n\n  function isFinalizeAgent() public constant returns(bool) {\n    return true;\n  }\n\n  /** Return true if we can run finalizeCrowdsale() properly.\n   *\n   * This is a safety check function that doesn't allow crowdsale to begin\n   * unless the finalizer has been set up properly.\n   */\n  function isSane() public constant returns (bool);\n\n  /** Called once by crowdsale finalize() if the sale was success. */\n  function finalizeCrowdsale();\n\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) constant returns (uint256);\n  function transfer(address to, uint256 value) returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) returns (bool);\n  function approve(address spender, uint256 value) returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n\n  uint public decimals;\n\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    require(newOwner != address(0));      \n    owner = newOwner;\n  }\n\n}\n\n\n/*\n * Haltable\n *\n * Abstract contract that allows children to implement an\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n *\n *\n * Originally envisioned in FirstBlood ICO contract.\n */\ncontract Haltable is Ownable {\n  bool public halted;\n\n  modifier stopInEmergency {\n    if (halted) throw;\n    _;\n  }\n\n  modifier stopNonOwnersInEmergency {\n    if (halted && msg.sender != owner) throw;\n    _;\n  }\n\n  modifier onlyInEmergency {\n    if (!halted) throw;\n    _;\n  }\n\n  // called by the owner on emergency, triggers stopped state\n  function halt() external onlyOwner {\n    halted = true;\n  }\n\n  // called by the owner on end of emergency, returns to normal state\n  function unhalt() external onlyOwner onlyInEmergency {\n    halted = false;\n  }\n\n}\n\n\n\n\n\n\n\n/**\n * Crowdsale state machine without buy functionality.\n *\n * Implements basic state machine logic, but leaves out all buy functions,\n * so that subclasses can implement their own buying logic.\n *\n *\n * For the default buy() implementation see Crowdsale.sol.\n */\ncontract CrowdsaleBase is Haltable {\n\n  /* Max investment count when we are still allowed to change the multisig address */\n  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n\n  using SafeMathLib for uint;\n\n  /* The token we are selling */\n  FractionalERC20 public token;\n\n  /* How we are going to price our offering */\n  PricingStrategy public pricingStrategy;\n\n  /* Post-success callback */\n  FinalizeAgent public finalizeAgent;\n\n  /* tokens will be transfered from this address */\n  address public multisigWallet;\n\n  /* if the funding goal is not reached, investors may withdraw their funds */\n  uint public minimumFundingGoal;\n\n  /* the UNIX timestamp start date of the crowdsale */\n  uint public startsAt;\n\n  /* the UNIX timestamp end date of the crowdsale */\n  uint public endsAt;\n\n  /* the number of tokens already sold through this contract*/\n  uint public tokensSold = 0;\n\n  /* How many wei of funding we have raised */\n  uint public weiRaised = 0;\n\n  /* Calculate incoming funds from presale contracts and addresses */\n  uint public presaleWeiRaised = 0;\n\n  /* How many distinct addresses have invested */\n  uint public investorCount = 0;\n\n  /* How much wei we have returned back to the contract after a failed crowdfund. */\n  uint public loadedRefund = 0;\n\n  /* How much wei we have given back to investors.*/\n  uint public weiRefunded = 0;\n\n  /* Has this crowdsale been finalized */\n  bool public finalized;\n\n  /** How much ETH each address has invested to this crowdsale */\n  mapping (address => uint256) public investedAmountOf;\n\n  /** How much tokens this crowdsale has credited for each investor address */\n  mapping (address => uint256) public tokenAmountOf;\n\n  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n  mapping (address => bool) public earlyParticipantWhitelist;\n\n  /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\n  uint public ownerTestValue;\n\n  /** State machine\n   *\n   * - Preparing: All contract initialization calls and variables have not been set yet\n   * - Prefunding: We have not passed start time yet\n   * - Funding: Active crowdsale\n   * - Success: Minimum funding goal reached\n   * - Failure: Minimum funding goal not reached before ending time\n   * - Finalized: The finalized has been called and succesfully executed\n   * - Refunding: Refunds are loaded on the contract for reclaim.\n   */\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n\n  // A new investment was made\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n\n  // Refund was processed for a contributor\n  event Refund(address investor, uint weiAmount);\n\n  // The rules were changed what kind of investments we accept\n  event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n\n  // Address early participation whitelist status changed\n  event Whitelisted(address addr, bool status);\n\n  // Crowdsale end time has been changed\n  event EndsAtChanged(uint newEndsAt);\n\n  State public testState;\n\n  function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n\n    owner = msg.sender;\n\n    token = FractionalERC20(_token);\n\n    setPricingStrategy(_pricingStrategy);\n\n    multisigWallet = _multisigWallet;\n    if(multisigWallet == 0) {\n        throw;\n    }\n\n    if(_start == 0) {\n        throw;\n    }\n\n    startsAt = _start;\n\n    if(_end == 0) {\n        throw;\n    }\n\n    endsAt = _end;\n\n    // Don't mess the dates\n    if(startsAt >= endsAt) {\n        throw;\n    }\n\n    // Minimum funding goal can be zero\n    minimumFundingGoal = _minimumFundingGoal;\n  }\n\n  /**\n   * Don't expect to just send in money and get tokens.\n   */\n  function() payable {\n    throw;\n  }\n\n  /**\n   * Make an investment.\n   *\n   * Crowdsale must be running for one to invest.\n   * We must have not pressed the emergency brake.\n   *\n   * @param receiver The Ethereum address who receives the tokens\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side'\n   *\n   * @return tokenAmount How mony tokens were bought\n   */\n  function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n\n    // Determine if it's a good time to accept investment from this participant\n    if(getState() == State.PreFunding) {\n      // Are we whitelisted for early deposit\n      if(!earlyParticipantWhitelist[receiver]) {\n        throw;\n      }\n    } else if(getState() == State.Funding) {\n      // Retail participants can only come in when the crowdsale is running\n      // pass\n    } else {\n      // Unwanted state\n      throw;\n    }\n\n    uint weiAmount = msg.value;\n\n    // Account presale sales separately, so that they do not count against pricing tranches\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n\n    // Dust transaction\n    require(tokenAmount != 0);\n\n    if(investedAmountOf[receiver] == 0) {\n       // A new investor\n       investorCount++;\n    }\n\n    // Update investor\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n\n    // Update totals\n    weiRaised = weiRaised.plus(weiAmount);\n    tokensSold = tokensSold.plus(tokenAmount);\n\n    if(pricingStrategy.isPresalePurchase(receiver)) {\n        presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n    }\n\n    // Check that we did not bust the cap\n    require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n\n    assignTokens(receiver, tokenAmount);\n\n    // Pocket the money, or fail the crowdsale if we for some reason cannot send the money to our multisig\n    if(!multisigWallet.send(weiAmount)) throw;\n\n    // Tell us invest was success\n    Invested(receiver, weiAmount, tokenAmount, customerId);\n\n    return tokenAmount;\n  }\n\n  /**\n   * Finalize a succcesful crowdsale.\n   *\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\n   */\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n\n    // Already finalized\n    if(finalized) {\n      throw;\n    }\n\n    // Finalizing is optional. We only call it if we are given a finalizing agent.\n    if(address(finalizeAgent) != 0) {\n      finalizeAgent.finalizeCrowdsale();\n    }\n\n    finalized = true;\n  }\n\n  /**\n   * Allow to (re)set finalize agent.\n   *\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\n   */\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n    finalizeAgent = addr;\n\n    // Don't allow setting bad agent\n    if(!finalizeAgent.isFinalizeAgent()) {\n      throw;\n    }\n  }\n\n  /**\n   * Allow crowdsale owner to close early or extend the crowdsale.\n   *\n   * This is useful e.g. for a manual soft cap implementation:\n   * - after X amount is reached determine manual closing\n   *\n   * This may put the crowdsale to an invalid state,\n   * but we trust owners know what they are doing.\n   *\n   */\n  function setEndsAt(uint time) onlyOwner {\n\n    if(now > time) {\n      throw; // Don't change past\n    }\n\n    if(startsAt > time) {\n      throw; // Prevent human mistakes\n    }\n\n    endsAt = time;\n    EndsAtChanged(endsAt);\n  }\n\n  /**\n   * Allow to (re)set pricing strategy.\n   *\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\n   */\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n    pricingStrategy = _pricingStrategy;\n\n    // Don't allow setting bad agent\n    if(!pricingStrategy.isPricingStrategy()) {\n      throw;\n    }\n  }\n\n  /**\n   * Allow to change the team multisig address in the case of emergency.\n   *\n   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\n   * (we have done only few test transactions). After the crowdsale is going\n   * then multisig address stays locked for the safety reasons.\n   */\n  function setMultisig(address addr) public onlyOwner {\n\n    // Change\n    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n      throw;\n    }\n\n    multisigWallet = addr;\n  }\n\n  /**\n   * Allow load refunds back on the contract for the refunding.\n   *\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n   */\n  function loadRefund() public payable inState(State.Failure) {\n    if(msg.value == 0) throw;\n    loadedRefund = loadedRefund.plus(msg.value);\n  }\n\n  /**\n   * Investors can claim refund.\n   *\n   * Note that any refunds from proxy buyers should be handled separately,\n   * and not through this contract.\n   */\n  function refund() public inState(State.Refunding) {\n    uint256 weiValue = investedAmountOf[msg.sender];\n    if (weiValue == 0) throw;\n    investedAmountOf[msg.sender] = 0;\n    weiRefunded = weiRefunded.plus(weiValue);\n    Refund(msg.sender, weiValue);\n    if (!msg.sender.send(weiValue)) throw;\n  }\n\n  /**\n   * @return true if the crowdsale has raised enough money to be a successful.\n   */\n  function isMinimumGoalReached() public constant returns (bool reached) {\n    return weiRaised >= minimumFundingGoal;\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isFinalizerSane() public constant returns (bool sane) {\n    return finalizeAgent.isSane();\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isPricingSane() public constant returns (bool sane) {\n    return pricingStrategy.isSane(address(this));\n  }\n\n  /**\n   * Crowdfund state machine management.\n   *\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\n   */\n  function getState() public constant returns (State) {\n    if(finalized) return State.Finalized;\n    else if (address(finalizeAgent) == 0) return State.Preparing;\n    else if (!finalizeAgent.isSane()) return State.Preparing;\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n    else if (block.timestamp < startsAt) return State.PreFunding;\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n    else if (isMinimumGoalReached()) return State.Success;\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n    else return State.Failure;\n  }\n\n  /** This is for manual testing of multisig wallet interaction */\n  function setOwnerTestValue(uint val) onlyOwner {\n    ownerTestValue = val;\n  }\n\n  /**\n   * Allow addresses to do early participation.\n   *\n   * TODO: Fix spelling error in the name\n   */\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n    earlyParticipantWhitelist[addr] = status;\n    Whitelisted(addr, status);\n  }\n\n\n  /** Interface marker. */\n  function isCrowdsale() public constant returns (bool) {\n    return true;\n  }\n\n  //\n  // Modifiers\n  //\n\n  /** Modified allowing execution only if the crowdsale is currently running.  */\n  modifier inState(State state) {\n    if(getState() != state) throw;\n    _;\n  }\n\n\n  //\n  // Abstract functions\n  //\n\n  /**\n   * Check if the current invested breaks our cap rules.\n   *\n   *\n   * The child contract must define their own cap setting rules.\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\n   * Called from invest().\n   *\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\n   *\n   * @return true if taking this investment would break our cap rules\n   */\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n\n  /**\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\n   */\n  function isCrowdsaleFull() public constant returns (bool);\n\n  /**\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\n   */\n  function assignTokens(address receiver, uint tokenAmount) internal;\n}\n\n\n\n/**\n * Abstract base contract for token sales with the default buy entry points.\n *\n * Handle\n * - start and end dates\n * - accepting investments\n * - minimum funding goal and refund\n * - various statistics during the crowdfund\n * - different pricing strategies\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\n *\n * Does not Handle\n *\n * - Token allocation (minting vs. transfer)\n * - Cap rules\n *\n */\ncontract Crowdsale is CrowdsaleBase {\n\n  /* Do we need to have unique contributor id for each customer */\n  bool public requireCustomerId;\n\n  /**\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\n    */\n  bool public requiredSignedAddress;\n\n  /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */\n  address public signerAddress;\n\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n  }\n\n  /**\n   * Preallocate tokens for the early investors.\n   *\n   * Preallocated tokens have been sold before the actual crowdsale opens.\n   * This function mints the tokens and moves the crowdsale needle.\n   *\n   * Investor count is not handled; it is assumed this goes for multiple investors\n   * and the token distribution happens outside the smart contract flow.\n   *\n   * No money is exchanged, as the crowdsale team already have received the payment.\n   *\n   * @param fullTokens tokens as full tokens - decimal places added internally\n   * @param weiPrice Price of a single full token in wei\n   *\n   */\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n\n    uint tokenAmount = fullTokens * 10**token.decimals();\n    uint weiAmount = weiPrice * fullTokens; // This can be also 0, we give out tokens for free\n\n    weiRaised = weiRaised.plus(weiAmount);\n    tokensSold = tokensSold.plus(tokenAmount);\n\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n\n    assignTokens(receiver, tokenAmount);\n\n    // Tell us invest was success\n    Invested(receiver, weiAmount, tokenAmount, 0);\n  }\n\n  /**\n   * Allow anonymous contributions to this crowdsale.\n   */\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n     bytes32 hash = sha256(addr);\n     if (ecrecover(hash, v, r, s) != signerAddress) throw;\n     if(customerId == 0) throw;  // UUIDv4 sanity check\n     investInternal(addr, customerId);\n  }\n\n  /**\n   * Track who is the customer making the payment so we can send thank you email.\n   */\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\n    if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants\n    if(customerId == 0) throw;  // UUIDv4 sanity check\n    investInternal(addr, customerId);\n  }\n\n  /**\n   * Allow anonymous contributions to this crowdsale.\n   */\n  function invest(address addr) public payable {\n    if(requireCustomerId) throw; // Crowdsale needs to track participants for thank you email\n    if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants\n    investInternal(addr, 0);\n  }\n\n  /**\n   * Invest to tokens, recognize the payer and clear his address.\n   *\n   */\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\n  }\n\n  /**\n   * Invest to tokens, recognize the payer.\n   *\n   */\n  function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n    // see customerid.py\n    if (bytes1(sha3(customerId)) != checksum) throw;\n    investWithCustomerId(msg.sender, customerId);\n  }\n\n  /**\n   * Legacy API signature.\n   */\n  function buyWithCustomerId(uint128 customerId) public payable {\n    investWithCustomerId(msg.sender, customerId);\n  }\n\n  /**\n   * The basic entry point to participate the crowdsale process.\n   *\n   * Pay for funding, get invested tokens back in the sender address.\n   */\n  function buy() public payable {\n    invest(msg.sender);\n  }\n\n  /**\n   * Set policy do we need to have server-side customer ids for the investments.\n   *\n   */\n  function setRequireCustomerId(bool value) onlyOwner {\n    requireCustomerId = value;\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n  }\n\n  /**\n   * Set policy if all investors must be cleared on the server side first.\n   *\n   * This is e.g. for the accredited investor clearing.\n   *\n   */\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n    requiredSignedAddress = value;\n    signerAddress = _signerAddress;\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n  }\n\n}\n\n\n\n/**\n * Collect funds from presale investors, buy tokens for them in a single transaction and distribute out tokens.\n *\n * - Collect funds from pre-sale investors\n * - Send funds to the crowdsale when it opens\n * - Allow owner to set the crowdsale\n * - Have refund after X days as a safety hatch if the crowdsale doesn't materilize\n * - Allow unlimited investors\n * - Tokens are distributed on PreICOProxyBuyer smart contract first\n * - The original investors can claim their tokens from the smart contract after the token transfer has been released\n * - All functions can be halted by owner if something goes wrong\n *\n */\ncontract PreICOProxyBuyer is Ownable, Haltable {\n  using SafeMath for uint;\n\n  /** How many investors we have now */\n  uint public investorCount;\n\n  /** How many wei we have raised totla. */\n  uint public weiRaised;\n\n  /** Who are our investors (iterable) */\n  address[] public investors;\n\n  /** How much they have invested */\n  mapping(address => uint) public balances;\n\n  /** How many tokens investors have claimed */\n  mapping(address => uint) public claimed;\n\n  /** When our refund freeze is over (UNIT timestamp) */\n  uint public freezeEndsAt;\n\n  /** What is the minimum buy in */\n  uint public weiMinimumLimit;\n\n  /** What is the maximum buy in */\n  uint public weiMaximumLimit;\n\n  /** How many weis total we are allowed to collect. */\n  uint public weiCap;\n\n  /** How many tokens were bought */\n  uint public tokensBought;\n\n   /** How many investors have claimed their tokens */\n  uint public claimCount;\n\n  uint public totalClaimed;\n\n  /** If timeLock > 0, claiming is possible only after the time has passed **/\n  uint public timeLock;\n\n  /** This is used to signal that we want the refund **/\n  bool public forcedRefund;\n\n  /** Our ICO contract where we will move the funds */\n  Crowdsale public crowdsale;\n\n  /** What is our current state. */\n  enum State{Unknown, Funding, Distributing, Refunding}\n\n  /** Somebody loaded their investment money */\n  event Invested(address investor, uint weiAmount, uint128 customerId);\n\n  /** Refund claimed */\n  event Refunded(address investor, uint value);\n\n  /** We executed our buy */\n  event TokensBoughts(uint count);\n\n  /** We distributed tokens to an investor */\n  event Distributed(address investor, uint count);\n\n  /**\n   * Create presale contract where lock up period is given days\n   */\n  function PreICOProxyBuyer(address _owner, uint _freezeEndsAt, uint _weiMinimumLimit, uint _weiMaximumLimit, uint _weiCap) {\n\n    owner = _owner;\n\n    // Give argument\n    if(_freezeEndsAt == 0) {\n      throw;\n    }\n\n    // Give argument\n    if(_weiMinimumLimit == 0) {\n      throw;\n    }\n\n    if(_weiMaximumLimit == 0) {\n      throw;\n    }\n\n    weiMinimumLimit = _weiMinimumLimit;\n    weiMaximumLimit = _weiMaximumLimit;\n    weiCap = _weiCap;\n    freezeEndsAt = _freezeEndsAt;\n  }\n\n  /**\n   * Get the token we are distributing.\n   */\n  function getToken() public constant returns(FractionalERC20) {\n    if(address(crowdsale) == 0)  {\n      throw;\n    }\n\n    return crowdsale.token();\n  }\n\n  /**\n   * Participate to a presale.\n   */\n  function invest(uint128 customerId) private {\n\n    // Cannot invest anymore through crowdsale when moving has begun\n    if(getState() != State.Funding) throw;\n\n    if(msg.value == 0) throw; // No empty buys\n\n    address investor = msg.sender;\n\n    bool existing = balances[investor] > 0;\n\n    balances[investor] = balances[investor].add(msg.value);\n\n    // Need to satisfy minimum and maximum limits\n    if(balances[investor] < weiMinimumLimit || balances[investor] > weiMaximumLimit) {\n      throw;\n    }\n\n    // This is a new investor\n    if(!existing) {\n      investors.push(investor);\n      investorCount++;\n    }\n\n    weiRaised = weiRaised.add(msg.value);\n    if(weiRaised > weiCap) {\n      throw;\n    }\n\n    // We will use the same event form the Crowdsale for compatibility reasons\n    // despite not having a token amount.\n    Invested(investor, msg.value, customerId);\n  }\n\n  function buyWithCustomerId(uint128 customerId) public stopInEmergency payable {\n    invest(customerId);\n  }\n\n  function buy() public stopInEmergency payable {\n    invest(0x0);\n  }\n\n\n  /**\n   * Load funds to the crowdsale for all investors.\n   *\n   *\n   */\n  function buyForEverybody() stopNonOwnersInEmergency public {\n\n    if(getState() != State.Funding) {\n      // Only allow buy once\n      throw;\n    }\n\n    // Crowdsale not yet set\n    if(address(crowdsale) == 0) throw;\n\n    // Buy tokens on the contract\n    crowdsale.invest.value(weiRaised)(address(this));\n\n    // Record how many tokens we got\n    tokensBought = getToken().balanceOf(address(this));\n\n    if(tokensBought == 0) {\n      // Did not get any tokens\n      throw;\n    }\n\n    TokensBoughts(tokensBought);\n  }\n\n  /**\n   * How may tokens each investor gets.\n   */\n  function getClaimAmount(address investor) public constant returns (uint) {\n\n    // Claims can be only made if we manage to buy tokens\n    if(getState() != State.Distributing) {\n      throw;\n    }\n    return balances[investor].mul(tokensBought) / weiRaised;\n  }\n\n  /**\n   * How many tokens remain unclaimed for an investor.\n   */\n  function getClaimLeft(address investor) public constant returns (uint) {\n    return getClaimAmount(investor).sub(claimed[investor]);\n  }\n\n  /**\n   * Claim all remaining tokens for this investor.\n   */\n  function claimAll() {\n    claim(getClaimLeft(msg.sender));\n  }\n\n  /**\n   * Claim N bought tokens to the investor as the msg sender.\n   *\n   */\n  function claim(uint amount) stopInEmergency {\n    require (now > timeLock);\n\n    address investor = msg.sender;\n\n    if(amount == 0) {\n      throw;\n    }\n\n    if(getClaimLeft(investor) < amount) {\n      // Woops we cannot get more than we have left\n      throw;\n    }\n\n    // We track who many investor have (partially) claimed their tokens\n    if(claimed[investor] == 0) {\n      claimCount++;\n    }\n\n    claimed[investor] = claimed[investor].add(amount);\n    totalClaimed = totalClaimed.add(amount);\n    getToken().transfer(investor, amount);\n\n    Distributed(investor, amount);\n  }\n\n  /**\n   * ICO never happened. Allow refund.\n   */\n  function refund() stopInEmergency {\n\n    // Trying to ask refund too soon\n    if(getState() != State.Refunding) throw;\n\n    address investor = msg.sender;\n    if(balances[investor] == 0) throw;\n    uint amount = balances[investor];\n    delete balances[investor];\n    if(!(investor.call.value(amount)())) throw;\n    Refunded(investor, amount);\n  }\n\n  /**\n   * Set the target crowdsale where we will move presale funds when the crowdsale opens.\n   */\n  function setCrowdsale(Crowdsale _crowdsale) public onlyOwner {\n    crowdsale = _crowdsale;\n\n    // Check interface\n    if(!crowdsale.isCrowdsale()) true;\n  }\n\n  /// @dev Setting timelock (delay) for claiming\n  /// @param _timeLock Time after which claiming is possible\n  function setTimeLock(uint _timeLock) public onlyOwner {\n    timeLock = _timeLock;\n  }\n\n  /// @dev This is used in the first case scenario, this will force the state\n  ///      to refunding. This can be also used when the ICO fails to meet the cap.\n  function forceRefund() public onlyOwner {\n    forcedRefund = true;\n  }\n\n  /// @dev This should be used if the Crowdsale fails, to receive the refuld money.\n  ///      we can't use Crowdsale's refund, since our default function does not\n  ///      accept money in.\n  function loadRefund() public payable {\n    if(getState() != State.Refunding) throw;\n  }\n\n  /**\n   * Resolve the contract umambigious state.\n   */\n  function getState() public returns(State) {\n    if (forcedRefund)\n      return State.Refunding;\n\n    if(tokensBought == 0) {\n      if(now >= freezeEndsAt) {\n         return State.Refunding;\n      } else {\n        return State.Funding;\n      }\n    } else {\n      return State.Distributing;\n    }\n  }\n\n  /** Interface marker. */\n  function isPresale() public constant returns (bool) {\n    return true;\n  }\n\n  /** Explicitly call function from your wallet. */\n  function() payable {\n    throw;\n  }\n}"
}