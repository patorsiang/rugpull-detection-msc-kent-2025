{
  "txn_nums": 13,
  "event_nums": 7,
  "creation_block": 4654184,
  "creation_timestamp": 1512103778,
  "life_time": 408231.0,
  "duration_seconds": 6125961.0,
  "from_creation_to_transfer": 0.0,
  "num_addresses": 9,
  "num_buyers": 2,
  "num_sellers": 8,
  "num_creator_transfers": 1,
  "buy_amt": 5.1e+17,
  "sell_amt": 8.15849032e+17,
  "avg_value": 9.470350228571429e+16,
  "txn_per_block": 3.184463736306806e-05,
  "avg_gas_limit": 250491.53846153847,
  "std_gas_limit": 701862.9529386681,
  "avg_gas_used": 238504.15384615384,
  "std_gas_used": 704970.5957583071,
  "avg_gas_price": 20923076923.076923,
  "std_gas_price": 15900950810.765705,
  "unpause_num": 1,
  "transfer_num": 1,
  "cashout_num": 1,
  "num_nodes": 8,
  "num_edges": 8,
  "avg_degree": 2.0,
  "density": 0.14285714285714285,
  "connected_components": 1,
  "avg_clustering": 0.0,
  "timeline_sequence": [
    [
      4654184,
      1512103778,
      0,
      15,
      0,
      2679620,
      20000000000,
      0,
      1,
      3765867,
      2679620,
      18438809
    ],
    [
      4654986,
      1512115197,
      4,
      10,
      0,
      42664,
      27000000000,
      0,
      1,
      274821,
      28443,
      18438007
    ],
    [
      4664734,
      1512253514,
      0,
      19,
      100000000000000000,
      90000,
      20000000000,
      0,
      1,
      598517,
      56326,
      18428259
    ],
    [
      4687291,
      1512595897,
      7,
      73,
      30000000000000000,
      84489,
      42000000000,
      0,
      1,
      3198426,
      56326,
      18405702
    ],
    [
      4718393,
      1513061018,
      44,
      29,
      200000000000000000,
      84489,
      50000000000,
      0,
      1,
      1124563,
      56326,
      18374600
    ],
    [
      4752773,
      1513577316,
      14,
      210,
      150000000000000000,
      21000,
      5000000000,
      1,
      0,
      7919738,
      21000,
      18340220
    ],
    [
      4755816,
      1513622883,
      20,
      160,
      150000000000000000,
      22000,
      5000000000,
      1,
      0,
      7107935,
      22000,
      18337177
    ],
    [
      4761322,
      1513708025,
      29,
      90,
      150000000000000000,
      56326,
      25000000000,
      0,
      1,
      5990098,
      56326,
      18331671
    ],
    [
      4801990,
      1514312595,
      32,
      149,
      30000000000000000,
      84489,
      10000000000,
      0,
      1,
      7757604,
      56326,
      18291003
    ],
    [
      4822989,
      1514622571,
      7,
      43,
      0,
      49779,
      27000000000,
      0,
      1,
      2658185,
      30927,
      18270004
    ],
    [
      5062415,
      1518229739,
      13,
      3,
      0,
      36934,
      41000000000,
      0,
      1,
      159781,
      36934,
      18030578
    ],
    [
      4822989,
      1514622571,
      0,
      0,
      510000000000000000,
      2300,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      5062397,
      1518229411,
      0,
      0,
      5849032000000000,
      2300,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "sourcecode": "/**\n*\n* Inspired by FirstBlood Token - firstblood.io\n*\n*/\n\npragma solidity ^0.4.16;\n\n/**\n* @title SafeMath\n* @dev Math operations with safety checks that throw on error\n**/\nlibrary SafeMath {\n\tfunction mul(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\t\treturn c;\n  \t}\n\n  \tfunction div(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a / b;\n\t\treturn c;\n  \t}\n\n\tfunction sub(uint256 a, uint256 b) internal returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal returns (uint256) {\n\t\t uint256 c = a + b;\n\t\t assert(c >= a);\n\t\t return c;\n\t}\n}\n\n/**\n* @title Ownable\n* @dev The Ownable contract has an owner address, and provides basic authorization control\n* functions, this simplifies the implementation of \"user permissions\".\n**/\ncontract Ownable {\n\taddress public owner;\n\n\t/**\n\t* @dev The Ownable constructor sets the original 'owner' of the contract to the sender\n\t* account.\n\t**/\n\tfunction Ownable() {\n\t\towner = msg.sender;\n\t}\n\n\t/**\n\t* @dev Throws if called by any account other than the owner.\n\t**/\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Allows the current owner to transfer control of the contract to a newOwner.\n\t* @param newOwner The address to transfer ownership to.\n\t**/\n\tfunction transferOwnership(address newOwner) onlyOwner {\n\t\tif (newOwner != address(0)) {\n\t\t\towner = newOwner;\n\t\t}\n\t}\n}\n\n/**\n* @title Pausable\n* @dev Base contract which allows children to implement an emergency stop mechanism.\n**/\ncontract Pausable is Ownable {\n\tevent Pause();\n\tevent Unpause();\n\tevent PauseRefund();\n\tevent UnpauseRefund();\n\n\tbool public paused = true;\n\tbool public refundPaused = true;\n\t// Deadline set to December 29th, 2017 at 11:59pm PST\n\tuint256 public durationInMinutes = 60*24*29+60*3+10;\n\tuint256 public dayAfterInMinutes = 60*24*30+60*3+10;\n\tuint256 public deadline = now + durationInMinutes * 1 minutes;\n\tuint256 public dayAfterDeadline = now + dayAfterInMinutes * 1 minutes;\n\n\t/**\n\t* @dev modifier to allow actions only when the contract IS NOT paused\n\t**/\n\tmodifier whenNotPaused() {\n\t\trequire(!paused);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev modifier to allow actions only when the refund IS NOT paused\n\t**/\n\tmodifier whenRefundNotPaused() {\n\t\trequire(!refundPaused);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev modifier to allow actions only when the contract IS paused\n\t**/\n\tmodifier whenPaused {\n\t\trequire(paused);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev modifier to allow actions only when the refund IS paused\n\t**/\n\tmodifier whenRefundPaused {\n\t\trequire(refundPaused);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev modifier to allow actions only when the crowdsale has ended\n\t**/\n\tmodifier whenCrowdsaleEnded {\n\t\trequire(deadline < now);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev modifier to allow actions only when the crowdsale has not ended\n\t**/\n\tmodifier whenCrowdsaleNotEnded {\n\t\trequire(deadline >= now);\n\t\t_;\n\t}\n\n\t/**\n\t* @dev called by the owner to pause, triggers stopped state\n\t**/\n\tfunction pause() onlyOwner whenNotPaused returns (bool) {\n\t\tpaused = true;\n\t\tPause();\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev called by the owner to pause, triggers stopped state\n\t**/\n\tfunction pauseRefund() onlyOwner whenRefundNotPaused returns (bool) {\n\t\trefundPaused = true;\n\t\tPauseRefund();\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev called by the owner to unpause, returns to normal state\n\t**/\n\tfunction unpause() onlyOwner whenPaused returns (bool) {\n\t\tpaused = false;\n\t\tUnpause();\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev called by the owner to unpause, returns to normal state\n\t**/\n\tfunction unpauseRefund() onlyOwner whenRefundPaused returns (bool) {\n\t\trefundPaused = false;\n\t\tUnpauseRefund();\n\t\treturn true;\n\t}\n}\n\n/**\n* @title ERC20Basic\n* @dev Simpler version of ERC20 interface\n* @dev see https://github.com/ethereum/EIPs/issues/179\n**/\ncontract ERC20Basic {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address who) constant returns (uint256);\n\tfunction transfer(address to, uint256 value) returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n* @title Basic token\n* @dev Basic version of StandardToken, with no allowances.\n**/\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t**/\n\tfunction transfer(address _to, uint256 _value) returns (bool) {\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tTransfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t**/\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n\t\treturn balances[_owner];\n\t}\n}\n\n/**\n* @title ERC20 interface\n* @dev see https://github.com/ethereum/EIPs/issues/20\n**/\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) constant returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) returns (bool);\n\tfunction approve(address spender, uint256 value) returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n* @title Standard ERC20 token\n*\n* @dev Implementation of the basic standard token.\n* @dev https://github.com/ethereum/EIPs/issues/20\n* @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n**/\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) allowed;\n\n\t/**\n\t* @dev Transfer tokens from one address to another\n\t* @param _from address The address which you want to send tokens from\n\t* @param _to address The address which you want to transfer to\n\t* @param _value uint256 the amout of tokens to be transfered\n\t**/\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n\t\tvar _allowance = allowed[_from][msg.sender];\n\n\t\trequire (_value <= _allowance);\n\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n\t\t\n\t\tTransfer(_from, _to, _value);\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t* @param _spender The address which will spend the funds.\n\t* @param _value The amount of tokens to be spent.\n\t**/\n\tfunction approve(address _spender, uint256 _value) returns (bool) {\n\t\t\n\t\t/**\n\t\t* To change the approve amount you first have to reduce the addresses'\n\t\t* allowance to zero by calling 'approve(_spender, 0)' if it is not\n\t\t* already 0 to mitigate the race condition described here: \n\t\thttps://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t\t**/\n\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n\t\tallowed[msg.sender][_spender] = _value;\n\t\tApproval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t* @param _owner address The address which owns the funds.\n\t* @param _spender address The address which will spend the funds.\n\t* @return A uint256 specifing the amount of tokens still available for the spender.\n\t**/\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n}\n\n/**\n* @title hodlToken\n* @dev All tokens are pre-assigned to the creator.\n* Tokens can be transferred using 'transfer' and other\n* 'StandardToken' functions.\n**/\ncontract hodlToken is Pausable, StandardToken {\n\n\tusing SafeMath for uint256;\n\n\taddress public escrow = this;\n\n\t//20% Finder allocation \n\tuint256 public purchasableTokens = 112000 * 10**18;\n\tuint256 public founderAllocation = 28000 * 10**18;\n\n\tstring public name = \"TeamHODL Token\";\n\tstring public symbol = \"THODL\";\n\tuint256 public decimals = 18;\n\tuint256 public INITIAL_SUPPLY = 140000 * 10**18;\n\n\tuint256 public RATE = 200;\n\tuint256 public REFUND_RATE = 200;\n\n\t/**\n\t* @dev Contructor that gives msg.sender all of existing tokens.\n\t**/\n\tfunction hodlToken() {\n\t\ttotalSupply = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t}\n\n\t/**\n\t* @dev Allows the current owner to transfer control of the contract to a newOwner.\n\t* @param newOwner The address to transfer ownership to.\n\t**/\n\tfunction transferOwnership(address newOwner) onlyOwner {\n\t\taddress oldOwner = owner;\n\t\tsuper.transferOwnership(newOwner);\n\t\tbalances[newOwner] = balances[oldOwner];\n\t\tbalances[oldOwner] = 0;\n\t}\n\n\t/**\n\t* @dev Allows the current owner to transfer escrowship of the contract to a escrow account.\n\t* @param newEscrow The address to transfer the escrow account to.\n\t**/\n\tfunction transferEscrowship(address newEscrow) onlyOwner {\n\t\tif (newEscrow != address(0)) {\n\t\t\tescrow = newEscrow;\n\t\t}\n\t}\n\n\t/**\n\t* @dev Allows the current owner to set the new total supply, to be used iff not all tokens sold during crowdsale.\n\t**/\n\tfunction setTotalSupply() onlyOwner whenCrowdsaleEnded {\n\t\tif (purchasableTokens > 0) {\n\t\t\ttotalSupply = totalSupply.sub(purchasableTokens);\n\t\t}\n\t}\n\n\t/**\n\t* @dev Allows the current owner to withdraw ether funds after ICO ended.\n\t**/\n\tfunction cashOut() onlyOwner whenCrowdsaleEnded {\n\t\t\n\t\t/**\n\t\t* Transfer money from escrow wallet up to 1 day after ICO end.\n\t\t**/\n\t\tif (dayAfterDeadline >= now) {\n\t\t\towner.transfer(escrow.balance);\n\t\t}\n\t}\n  \n\t/**\n\t* @dev Allows owner to change the exchange rate of tokens (default 0.005 Ether)\n\t**/\n\tfunction setRate(uint256 rate) {\n\n\t\t/**\n\t\t* If break-even point has been reached (3500 Eth = 3.5*10**21 Wei),\n\t\t* rate updates to 20% of total revenue (100% of dedicated wallet after forwarding contract)\n\t\t**/\n\t\tif (escrow.balance >= 7*10**20) {\n\n\t\t\t/**\n\t\t\t* Rounds up to address division error\n\t\t\t**/\n\t\t\tRATE = (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000);\n\t\t}\n\t}\n  \n\t/**\n\t* @dev Allows owner to change the refund exchange rate of tokens (default 0.005 Ether)\n\t* @param rate The number of tokens to release\n\t**/\n\tfunction setRefundRate(uint256 rate) {\n\n\t\t/**\n\t\t* If break-even point has been reached (3500 Eth = 3.5*10**21 Wei),\n\t\t* refund rate updates to 20% of total revenue (100% of dedicated wallet after forwarding contract)\n\t\t**/\n\t\tif (escrow.balance >= 7*10**20) {\n\n\t\t\t/**\n\t\t\t* Rounds up to address division error\n\t\t\t**/\n\t\t\tREFUND_RATE = (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000);\n\t\t}\n\t}\n\n\t/**\n\t* @dev fallback function\n\t**/\n\tfunction () payable {\n\t\tif(now <= deadline){\n\t\t\tbuyTokens(msg.sender);\n\t\t}\n\t}\n\n\t/**\n\t* @dev function that sells available tokens\n\t**/\n\tfunction buyTokens(address addr) payable whenNotPaused whenCrowdsaleNotEnded {\n\t\t\n\t\t/**\n\t\t* Calculate tokens to sell and check that they are purchasable\n\t\t**/\n\t\tuint256 weiAmount = msg.value;\n\t\tuint256 tokens = weiAmount.mul(RATE);\n\t\trequire(purchasableTokens >= tokens);\n\n\t\t/**\n\t\t* Send tokens to buyer\n\t\t**/\n\t\tpurchasableTokens = purchasableTokens.sub(tokens);\n\t\tbalances[owner] = balances[owner].sub(tokens);\n\t\tbalances[addr] = balances[addr].add(tokens);\n\n\t\tTransfer(owner, addr, tokens);\n\t}\n  \n\tfunction fund() payable {}\n\n\tfunction defund() onlyOwner {}\n\n\tfunction refund(uint256 _amount) payable whenNotPaused whenCrowdsaleEnded {\n\n\t\t/**\n\t\t* Calculate amount of THODL to refund\n\t\t**/\n\t\tuint256 refundTHODL = _amount.mul(10**18);\n\t\trequire(balances[msg.sender] >= refundTHODL);\n\n\t\t/**\n\t\t* Calculate refund in wei\n\t\t**/\n\t\tuint256 weiAmount = refundTHODL.div(REFUND_RATE);\n\t\trequire(this.balance >= weiAmount);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(refundTHODL);\n\t\t\n\t\t/**\n\t\t* The tokens are burned\n\t\t**/\n\t\ttotalSupply = totalSupply.sub(refundTHODL);\n\n\t\tmsg.sender.transfer(weiAmount);\n\t}\n}"
}